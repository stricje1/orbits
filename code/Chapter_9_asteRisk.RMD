---
title: "Orbital Parameters and State Vectors"
author: "Jeffrey Strickland"
date: '2022-09-06'
output: word_document
always_allow_html: true
---

```{r}
knitr::opts_chunk$set(echo=TRUE, message=FALSE, fig.path='figures/', dpi=300, digits = 2)
options(digits = 5, scipen = 100)
hasData <- requireNamespace("asteRiskData", quietly = TRUE, cache = TRUE, autodep = TRUE, fig.align = "center", warning = FALSE, message = FALSE)
if (!hasData) {                                                                 
  evaluateExtraChunks <- FALSE                                             
  msg <- strwrap("Note: some examples in this vignette require that the
                 `asteRiskData` package be installed. The system
                  currently running this vignette does not have that package
                  installed, so code examples will not be evaluated.")
  msg <- paste(msg, collapse="\n")
  message(msg)                                                                   
} else {
  evaluateExtraChunks <- TRUE
  library(asteRiskData)
}
```

## Introduction

Unlike positional information available for military aircraft we use to perform six-degrees of modeling (6DOF), satellite positions are not readily available for any time-point along their orbits. Instead, **orbital state vectors** at discrete and relatively scarce time-points, and generated from multiple observations, are generated by entities with access to such information, such as the *United States Space Force*. Unclassified information can be obtained through resources such as *Space-Track* and *CelesTrak*, most commonly in the form of two- or three-line elements (TLE)sets .

However, due to the periodicity of the trajectories (orbits) followed by satellites, if the state vector of an object orbiting Earth is known at a given time, it is possible to predict their state vectors at future or project them in the past. In order to accurately perform such predictions, known as **orbit propagation**, it is necessary to use complex models that take into consideration not only the gravitational attraction of Earth, but also atmospheric drag and  periodic perturbations of the Moon and the Sun, among other effects.

The most widely applied models are the **SGP4** and **SDP4** propagators, whose first implementations were introduced in FORTRAN IV in 1988. *asteRisk* aims to constitute the basis for **astrodynamics analysis** in `R`. To that extent, it provides a native `R` implementation of the SGP4 and SDP4 models and utilities to parse and read TLE files and to convert coordinates between different reference frames. Additionally, a high-precision **orbital propagator** is also provided. High-precision propagators model a set of forces that act on satellites to calculate the resulting acceleration, and propagate the orbit by numerically solving the resulting differential equation for the position.

## Validation against the official algorithm
This implementation passes all the automated tests in the August 2010 release of the reference implementation of SGP4 by Vallado et al., who originally published their revision of SGP4 in 2006:

> Vallado, David A., Paul Crawford, Richard Hujsak, and T.S. Kelso, “Revisiting Spacetrack Report #3,” presented at the AIAA/AAS Astrodynamics Specialist > Conference, Keystone, CO, 2006 August 21–24.

If you would like to review the paper, it is available online. You can always download the latest version of their code for comparison against this Python module (or other implementations) at AIAA- https://www.celestrak.com/publications/AIAA/2006-6753/AIAA-2006-6753.zip.

## Installation instructions

Before we install *asteRisk*, we need to ensure we have the latest version of `R` installed. To install *asteRisk*, restart `R` and enter:

```{r}
#install.packages("asteRisk")
```

Once installed, the package can be loaded as shown below:

```{r}
library(asteRisk)
```

## Reading TLE and RINEX files

The **TLE** is the standard format for representing **orbital state vectors**. In short, TLEs have 2 lines that contain the **orbital parameters** that characterize the state of a satellite at a given time, known as an **epoch**. An additional initial line can be present to indicate the name of the satellite. A detailed description of the TLE format can be found below.

*asteRisk* provides the utilities to read TLE files (function `readTLE()`), and to directly parse character vectors containing the lines of a TLE as strings (function `parseTLElines()`). The resulting lists contain:

**LINE 1**

* Line number (1)
* NORAD catalog number of the satellite
* Classification level of the information
* International designator (last two digits of launch year)
* International designator (launch number and year)
* International designator (launch piece)
* Date and time of the state vector
*	Epoch year (last two digits of year)
* Epoch (day of the year and fractional portion of the day)
* First derivative of mean motion; the ballistic coefficient
* Second derivative of mean motion 
* B*, the drag term, or radiation pressure coefficient
* Ephemeris type (always zero; only used in undistributed TLE data)
* Element set number.
* Checksum (modulo 10)

**LINE 2**

* Line number(2)
* Satellite Catalog number
* Inclination ($i$) (degrees)
* Longitude of the ascending node ($\Omega$) (degrees)
* Eccentricity ($e$)
* Argument of perigee or periapsis ($\omega$) (degrees) 
* Mean anomaly ($M$) (degrees)
* Mean motion ($n$) (revolutions per day)
* Revolution number at epoch (revolutions)
* Checksum (modulo 10)

## Orbital Elements Computations

Orbital elements, generally six including eccentricity, inclination, semimajor axis, argument of perigee, longitude of the ascending node, mean motion, and mean anomaly, appear in line two of the TLE. However, propagators require more parameter equations to produce the position velocity and vector velocity need for locating space objects.

* Inclination $(i, \text{ where } i = \text{arccos}\frac{h_z}{\mathbf{h}},\text{ with } h_z = z-component \text{ of } \mathbf{h})$ (degrees)
* Longitude of the ascending node ($\Omega, \text{ where } \Omega = \begin{bmatrix} arccos \frac{n_x}{|\mathbf{n}|}, &n_y \ge 0\\ 2\pi - arccos \frac{n_x}{|{\mathbf{n}}|},&n_y < 0 \\ \end{bmatrix}$ (degrees)
* Eccentricity $(e, \text{ where } e = |\mathbf{e}|)$, orbits: circular, $e=0$; elliptic, $0<e<1$; parabolic, $e=1$; hyperbolic, $e>1$)
* Argument of perigee or periapsis ($\omega\text{ where } \omega = \text{arccos}\frac{\mathbf{\mathbf{n} \cdot \mathbf{e}}}{\mathbf{|\mathbf{n}||\mathbf{e}|}})$) (degrees) 
* Mean anomaly $(M, \text{ where } M = \ell - \varpi)$ (degrees)
* Mean motion $(n, \text{ where } n = \frac{1}{a})$ (revolutions per day)
* Orbital momentum vector $(\mathbf{h} \text{ where } h = \mathbf{r} \times \mathbf{v},\text{ with } \mathbf{r} = \text{ position vector and }\mathbf{v} = \text{ velocity vector})$
* Semimajor axis $(a, \text{ where } a = \sqrt{-2\xi} )$
* Semiminor axis $(b, \text{ where } b = a\sqrt{1-e^2} \text{ or } b = \sqrt{a\ell})$
* Linear eccentricity $(c, \text{ where } = ae)$
* True anomaly $(\nu, \text{ where } \nu = \text{arccos} \frac{\mathbf{er}}{\mathbf{|e||r|}})$
* Focal parameter $(p, \text{ where } p = \frac{a}{e}-c)$
* Mean longitude $(\mathrm{l}, \text{ where } l = \varpi + M)$
* True longitude $(l, \text{ where } \mathscr + \nu)$
* Semi-latus rectum $(\ell, \text{ where } \ell = pe)$
* Specific angular momentum $(h, \text{ where } h = \frac{n}{a \cdot b})$
* Specific mechanical energy $(\xi, \text{ where } \xi = -\frac{\mu}{2 \cdot a}$
* Longitude of the periapsis $(\varpi, \text{ where } \varpi = \Omega + \omega)$
* Standard gravitational constant $(G = 6.67430 \times 10^{-11})$
* Standard gravitational parameter $(\mu = 3.986004 \times 10^{14})$ [Earth]

## Example TLE

`ISS (ZARYA)`
`1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927`
`2 25544  51.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537`

A file with a set of 29 TLE, provided in Revisiting Space Track Report #3 and typically used to benchmark implementations of the SGP4/SDP4 propagators, is distributed with *asteRisk*, in file named testTLE.txt:

Now, we'll read the provided `testTLE` file comprised of 29 benchmark TLE, which contains objects with a variety of orbital parameters

```{r}
test_TLEs <- readTLE(paste0(path.package("asteRisk"), "/testTLE.txt"))
```

TLE number 17 contains a state vectors for Italsat 2

```{r}
tle19<-test_TLEs[[19]]
tle_lab <- data.frame("label"=c(names(tle19)))
tle_val <- data.frame("value"=
c(tle19$NORADcatalogNumber, tle19$classificationLevel, tle19$internationalDesignator, tle19$launchYear, tle19$launchNumber, tle19$launchPiece, tle19$dateTime, tle19$elementNumber, tle19$inclination, tle19$ascension, tle19$eccentricity, tle19$perigeeArgument, tle19$meanAnomaly, tle19$meanMotion, tle19$meanMotionDerivative, tle19$meanMotionSecondDerivative, tle19$Bstar, tle19$ephemerisType, tle19$epochRevolutionNumber, tle19$objectName))
tle_tab<-cbind(tle_lab$label,tle_val$value)
knitr::kable(tle_tab)
```

It is also possible to directly parse a character vector with 2 or 3 elements, where each element is a string representing a line of the TLE, to obtain the same result:

```{r}
italsat2_lines <- c("ITELSAT 2",
"1 24208U 96044A   06177.04061740 -.00000094  00000-0  10000-3 0  1600",
"2 24208   3.8536  80.0121 0026640 311.0977  48.3000  1.00778054 36119")

italsat2_TLE <- parseTLElines(italsat2_lines)

```

**RINEX** (Receiver Independent Exchange Format), on the other hand, is one of the most widely used formats for providing data of **global satellite navigation systems** (GNSS). The RINEX standard defines several file types, among which navigation files are used to distribute positional information of the satellites. While the format is mainly limited for GNSS, it is of interest for satellite positioning applications given the large amounts of publicly available, high-precision data for such satellite constellations.

The exact information provided in a RINEX navigation file varies for each GNSS. For example, while GLONASS navigation files provide directly the position, velocity and acceleration in the GCRF frame of coordinates, GPS navigation files provide orbital elements.

*asteRisk* provides functions to read RINEX navigation files for GPS and GLONASS satellites (functions `readGPSNavigationRINEX()` and `readGLONASSNavigationRINEX()` respectively):

```{r}
# Read the provided test RINEX navigation files for both GPS and GLONASS:

testGPSnav <- readGPSNavigationRINEX(paste0(path.package("asteRisk"), 
"/testGPSRINEX.txt"))
testGLONASSnav <- readGLONASSNavigationRINEX(paste0(path.package("asteRisk"), 
"/testGLONASSRINEX.txt"))

# Count the number of positional messages in each file:

length(testGPSnav$messages)
length(testGLONASSnav$messages)
```
#### ===========================================================

## Propagation of orbits

#### ===========================================================

The two orbit propagators currently available in *asteRisk* are the SGP4 and SDP4 models. They allow the calculation of the **position** and **velocity** Vectors of the satellite at different times, both before and after the time corresponding to the known state vector (referred to as "epoch"). *Kepler's equation* is solved through fixed-point integration. It should be noted that the SGP4 model can only accurately propagate the orbit of objects near Earth (with an orbital period shorter than 225 minutes, corresponding approximately to an altitude lower than 5877.5 km).

For propagation of objects in **deep space** (with orbital periods larger than 225 minutes, corresponding to altitudes higher than 5877.5 km), the SDP4 model should be used, which contains additions to take into account the secular and periodic perturbations of the Moon and the Sun on the orbit of the satellite. It also considers Earth resonance effects on 24-hour geostationary and 12-hour Molniya orbits.

However, it should be noted that SDP4 employs only simplified drag equations, and lacks corrections for low-perigee orbits. Therefore, it is recommended to apply the standard SGP4 model for satellites that are not in deep space.

*asteRisk* provides three functions to apply the SGP4/SDP4 propagators. The `sgdp4()` function automatically determines if the satellite is in deep space or near Earth, and applies the appropriate model. The application of either SGP4 or SDP4 can be forced with the `sgp4()` and `sdp4()` functions respectively. However, it is not recommended to apply SGP4 to objects in deep space or SDP4 to objects near Earth. In the following example, we calculate and visualize the trajectory of a satellite with a high-eccentricity **Molniya orbit**:


Element 11 of the set of test TLE contains an orbital state vector for satellite MOLNIYA 1-83, launched from the USSR in 1992 and decayed in 2007.

```{r}
molniya <- test_TLEs[[11]]
1/molniya$meanMotion
```

From the inverse of the mean motion, we can see that the orbital period is  approximately half a day, in accordance with a Molniya orbit Let´s use the SDP4 model to calculate the position and velocity of the satellite for a full orbital period every 10 minutes. It is important to provide the mean motion in radians/min, the inclination, anomaly,  argument of perigee and longitude of the ascending node in radians, and the target time as an increment in minutes for the epoch time.

```{r}
targetTimes <- seq(0, 1800, by=5)

results_position_matrix <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result <- sgdp4(n0=1.00273847*((2*pi)/(1440)),
                        e0=0.9475409674714041,
                        i0=2.165043638879379*pi/180,
                        M0=2.7857482293260034*pi/180,
                        omega0=5.2899364871506*pi/180,
                        OMEGA0=3.3269406035854874*pi/180,
                        Bstar=1e-04,
                        initialDateTime='2006-04-16 17:52:50.8054079998419', targetTime = targetTimes[i])
    results_position_matrix[i,] <- new_result[[1]]
    results_velocity_matrix[i,] <- new_result[[2]]
}
last_molniya_propagation <- new_result
results_position_matrix = cbind(results_position_matrix, targetTimes)
colnames(results_position_matrix) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

last_molniya_propagation$algorithm
```

We can visualize the resulting trajectory using a `plotly` animation to confirm that our satellite completed a full revolution and it was in a **highly eccentric orbot** or HEO.

```{r}
library(plotly)
library(lazyeval)
library(dplyr)
library(pracma)
```

In order to create the animation, we must first define a function to create the accumulated dataframe required for the animation

```{r}
accumulate_by <- function(dat, var) {
    var <- f_eval(var, dat)
    lvls <- plotly:::getLevels(var)
    dats <- lapply(seq_along(lvls), function(x) {
        cbind(dat[var %in% lvls[seq(1, x)], ], frame = lvls[[x]])
    })
    bind_rows(dats)
}

accumulated_df <- accumulate_by(as.data.frame(results_position_matrix), ~time)

orbit_animation <- plot_ly(accumulated_df, x = ~x, y=~y, z=~z, type = "scatter3d",
                           mode="marker", opacity=0.8, line=list(width = 6, 
                                                                 color = ~time, 
                                                                 reverscale = FALSE), 
                           frame= ~frame)

orbit_animation <- animation_opts(orbit_animation, frame=50)

orbit_animation <- layout(orbit_animation, scene = list(
    xaxis=list(range=c(min(results_position_matrix[,1]), max(results_position_matrix[,1]))),
    yaxis=list(range=c(min(results_position_matrix[,2]), max(results_position_matrix[,2]))),
    zaxis=list(range=c(min(results_position_matrix[,3]), max(results_position_matrix[,3])))
))

orbit_animation
```

### Interatcive 3D Plot Using Ploty

We can produce an interactive 3D plot like the one we made for animation, without the animation

```{r, fig.width = 5, fig.height = 4.5, fig.}
p <- plot_ly(
     accumulated_df, x = ~x, y = ~x, z = ~z, 
     color = 'red', colors = c('lightblue', 'navyblue'), size=I(50)) %>%
     add_markers() %>%
     layout(
         scene = list(xaxis = list(title = 'x position'),
                      yaxis = list(title = 'y position'),
                      zaxis = list(title = 'z position'))
     ) 
p
```

### Simple Plotly 3D Plot
Although this code chunk is producing a 3D plot, it is shown on a 2d surface. The spacing of the point gives if the appearance of depth (the points are further apart)

```{r, fig.width=5, fig.height=4}
library(plotly)
x <- accumulated_df$x 
y <- accumulated_df$y
z <- accumulated_df$z
new_df <- data.frame(cbind(x,y,z))
p <- plot_ly(new_df,x=x,y=y,z=z, type = "scatter")
add_markers(p, symbol = 16)
p 
```


### 3D Orbital Plot using plot3d

This 3D plot is akin to a heatmap, in that shows the "cooler" point farther away for our viewing perspective.

```{r, fig.width=8, fig.height=6}
library(plot3D)
x <- accumulated_df$x 
y <- accumulated_df$y
z <- accumulated_df$z
scatter3D(x, y, z, xlab='x-position', ylab='y-position',
	  zlab='z-position', phi = 0, bty = "b", pch = 20, 
	  cex = 2,  revolutions=3, speed =1)

# bty = “b”, “b2”, “f”, “g”, “bl”, “bl2”, “u”, “n”
```

## Plotly 3D Scatter Plot with Color Scaling

Here, point markers will be colored according to the time. The "coolest" point are older.

```{r}
# Point colors
marker <- list(color = ~time, colorscale = c('#FFE1A1', '#683531'), 
              showscale = TRUE)
# Create the plot
p <- plot_ly(accumulated_df, x = ~x, y = ~x, z = ~z, marker = marker) %>%
     add_markers() %>%
     layout(
         scene = list(xaxis = list(title = 'x position'),
                      yaxis = list(title = 'y position'),
                      zaxis = list(title = 'z position'))
        )
p
```

## Conversion between reference frames

The positions and velocities calculated with the SGP4 and SDP4 models are in the **True Equator, Mean Equinox** (TEME) frame of reference, which is an **Earth-centered inertial** (ECI) coordinate frame, where the origin is placed at the center of mass of Earth and the coordinate frame is fixed with respect to the stars (and therefore not fixed with respect to the Earth surface in its rotation).

*asteRisk* provides the `TEMEtoITRF()` function, which converts positions and velocities in TEME to the **International Terrestrial Reference Frame** (ITRF) frame of reference. The ITRF is an **Earth Centered, Earth Fixed** (ECEF) frame of reference, i.e., a non-inertial frame of reference where the origin is also placed at the center of mass of Earth, and the frame rotates with respect to the stars to remain fixed with respect to the Earth surface as it rotates.

Additionally, the `TEMEtoLATLON()` and `ITRFtoLATLON()` functions convert Cartesian coordinates to **geodetic latitude**, **geodetic longitude** and **altitude** values, from the TEME and ITRF frames respectively. This can be useful, for example, to visualize the ground track followed by a satellite.

Several of the functions for conversion of systems of coordinates require Earth orientation parameters, which are provided through the **asteRiskData** accessory package. If you have not done so, you will need to install `asteRiskData` and we have found only one way to do this, namely using `install.packages('asteRiskData', repos='https://rafael-ayala.github.io/drat/')`

## Change Frame of Reference

Let us convert the last propagation previously calculated for the MOLNIYA 1-83 satellite into the ITRF frame. In order to do so, it is required to provide a date-time string indicating the time for the newly calculated position and velocity. Since this was 720 minutes after the epoch for the original state vector, we can just add 12 hours to it.

```{r}
library(asteRiskData)
getLatestSpaceData (targets="all")


molniya$dateTime

new_dateTime <- "2006-06-25 12:33:43"

ITRF_coordinates <- TEMEtoITRF(last_molniya_propagation$position,
                               last_molniya_propagation$velocity,
                               new_dateTime)

```

## Cordinate Transformation

Now, let's convert the previously calculated set of `TEME` coordinates to geodetic latitude and longitude.

```{r}
geodetic_matrix <- matrix(nrow=nrow(results_position_matrix), ncol=3)

for(i in 1:nrow(geodetic_matrix)) {
    new_dateTime <- as.character(as.POSIXct(molniya$dateTime, tz="UTC") + 60*targetTimes[i])
    new_geodetic <- TEMEtoLATLON(results_position_matrix[i, 1:3]*1000,
                                 new_dateTime)
    geodetic_matrix[i,] <- new_geodetic
}
colnames(geodetic_matrix) <- c("latitude", "longitude", "altitude")
```

## Ground Track View

We can now visualize the ground track of our satellite.
 
```{r}
library(ggmap)

ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) +
  #geom_segment(data=as.data.frame(geodetic_matrix), 
               #aes(x=longitude, y=latitude, 
                   #xend=c(tail(longitude, n=-1), NA), 
                   #yend=c(tail(latitude, n=-1), NA)), 
               #na.rm=TRUE) +
  geom_point(data=as.data.frame(geodetic_matrix), aes(x=longitude, y=latitude), 
             color="blue", size=2, alpha=0.8)
```

## High-precision orbital propagator

The *SGP4**/SDP4 models** provide a good accuracy at a low computational cost. However, higher precision can be achieved in orbit propagation by calculating at each instant the acceleration of the satellite resulting from the set of forces that are exerted on it, and solving the second-order ODE that expressed acceleration as the second time-derivative of position through numerical integration. Such propagators are often referred to as **high-precision orbital propagators (HPOP)**. The HPOP implemented in *asteRisk* takes into consideration Earth gravitational attraction (using a **geopotential model** based on spherical harmonics); the effects of Earth ocean and solid tides, the attraction of the Sun, Moon and planets; solar radiation pressure; atmospheric drag, and relativistic effects. The HPOP can be used through the `hpop()` function. However, it should be kept in mind that, while the HPOP can achieve a much higher precision, it also has much higher computational cost. It should also be noted that the HPOP requires access to data such as Earth orientation parameters, space weather data and solar and geomagnetic storms. Such data is provided in the *asteRiskData* accessory package, which, as previously mentioned, can be installed by running "install.packages('asteRiskData', repos='https://rafael-ayala.github.io/drat/')". After having installed the accessory package, it is possible to update the data and coefficients to the latest available versions with the `getLatestSpaceData()` function.

## Calculating HPOP Parameter Values

The HPOP requires as input the satellite mass, the effective areas subjected to solar radiation pressure and atmospheric drag, and the drag and reflectivity coefficients.  The mass and cross-section of Molniya satellites are approximately 1600 kg and 15 m2, respectively. We will use the cross-section to approximate the effective area for both atmospheric drag and radiation pressure. Regarding the drag and reflectivity coefficients, while their values vary for each satellite and orbit, 2.2 and 1.2 respectively can be used as approximations.

```{r}
library(ggmap)
molniyaMass <- 1600
molniyaCrossSection <- 15
molniyaCd <- 2.2
molniyaCr <- 1.2
```

## Define Initial Condiitions

As initial conditions, we will use the initial conditions provided in the same TLE for MOLNIYA 1-83 used previously for the SGP4/SDP4 propagator. We first need to calculate the initial position and velocity in the GCRF ECI frame of reference from the provided orbital elements.  As an approximation, we will use the results obtained for t = 0 with the SGP4/SDP4 propagator. We convert those into the GCRF frame of reference. It should be noted that such an approximation introduces an error due to a mismatch between the position derivative calculated at each propagation point through SGP4/SDP4 and the actual velocity of the satellite.

```{r}
GCRF_coordinates <- TEMEtoGCRF(results_position_matrix[1,1:3]*1000,
                               results_velocity_matrix[1,1:3]*1000, 
                               molniya$dateTime)

initialPosition <- GCRF_coordinates$position
initialVelocity <- GCRF_coordinates$velocity
```

Now, let´s use the HPOP to calculate the position each 2 minutes during a period of 3 hours.

```{r}
targetTimes <- seq(0, 20800, by=60)

hpop_results <- hpop(initialPosition, initialVelocity, molniya$dateTime,
                     targetTimes, molniyaMass, molniyaCrossSection,
                     molniyaCrossSection, molniyaCr, molniyaCd)
```

# Plot the Ground Trace

Now we can calculate and plot the corresponding geodetic coordinates.

```{r}
geodetic_matrix_hpop <- matrix(nrow=nrow(hpop_results), ncol=3)

for(i in 1:nrow(geodetic_matrix_hpop)) {
    new_dateTime <- as.character(as.POSIXct(molniya$dateTime, tz="UTC") + targetTimes[i])
    new_geodetic <- GCRFtoLATLON(as.numeric(hpop_results[i, 2:4]), new_dateTime)
    geodetic_matrix_hpop[i,] <- new_geodetic
}

colnames(geodetic_matrix_hpop) <- c("latitude", "longitude", "altitude")

library(ggmap)

ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) +
  geom_segment(data=as.data.frame(geodetic_matrix_hpop), 
               aes(x=longitude, y=latitude, 
                   xend=c(tail(longitude, n=-1), NA), 
                   yend=c(tail(latitude, n=-1), NA)), 
               na.rm=TRUE) +
  geom_point(data=as.data.frame(geodetic_matrix_hpop), aes(x=longitude, y=latitude), 
             color="blue", size=0.3, alpha=0.8)

```


## Cartesian State to Keplerian Elements
The conversion from the Cartesian state to the Keplerian elements has four special cases: elliptic inclined, circular inclined, elliptic equatorial, and circular equatorial. Certain orbital elements are undefined for some
of the cases. For example, the right ascension of the ascending node, $\Omega$, is undefined for equatorial orbits. However, computer systems don’t handle undefined values gracefully. In this section, we’ll see how the orbital elements are defined for each of the special cases, and how GMAT calculates the orbital elements for each case.

Given: r, v, and µ

Find: a, e, i, omega, Omega, and nu.

We begin by calculating the specific angular momentum and its magnitude.

```{r}
library(pracma)

molniyaMass <- 1600
molniyaCrossSection <- 15
molniyaCd <- 2.2
molniyaCr <- 1.2

mu = 3.986004418e14 # gravitational parameter
vM = 0.05*pi # between -Pi and +Pi
r0 <- GCRF_coordinates$position #new_state1$position
v0 <- GCRF_coordinates$velocity #new_state1$velocity

h0 = pracma::cross(r0,v0) # h vector cross product;    Eq. (3.1)
# all five norm type are the same for vectors
h1 = norm(as.matrix(h0))                             # Eq. (3.2)
hz = h0[3]

id3 = as.vector(c(0,0,1))
n0 = pracma::cross(id3, h0)                           # Eq. (3.3) 
n1 = norm(as.matrix(n0))                              # Eq. (3.4)
 
r1 <- norm(as.matrix(r0))                             # Eq. (3.5)
v1 <- norm(as.matrix(v0))                             # Eq. (3.6)

e0 <- ((v1^2-mu/v1)*r0-dot(r0,v0)*v0)/mu              # Eq. (3.7)
e1 <- norm(as.matrix(e0))                             # Eq. (3.8)

xi <- v1^2/2 - mu/r1                                  # Eq. (3.9)

a0 = -mu/(2*xi)                                       # Eq. (3.10)

i0 = acos(hz/h1)                                      # Eq. (3.11)

```

### Special Case 1: Non-circular, Inclined Orbit

```{r}
# CASE 1
const5 <- e1>10e-11&i0>-10e-11&i0<=pi-10e-11
const5A <- n0[2] < 0
const5B <- e0[3] < 0
const5C <- pracma::cross(r0,v0)<0
if (const5 == TRUE){
   Omega0 = acos(dot(n0,e0)/(n1*e1))         # Eq. (3.12)
   omega0 = acos(dot(n0,e0)/(n1*r1))         # Eq. (3.13)
   nu0    = acos(dot(e0,r0)/(e1*r1))         # Eq. (3.14)
   if (const5A == TRUE){  
       Omega0 = 2*pi-Omega0 
      if (const5B == TRUE){
         omega0 = 2*pi-omega0
         if (const5C == TRUE){ 
            nu0 = 2*pi - nu0
            print(paste("-------------------------------"))
            print(paste("CASE 1"))
            print(paste("Omega =", Omega0))
            print(paste("Omega =", omega0))
            print(paste("Nu    =", nu0))
            
         }
      }
   }
} else {
  print(paste("Not CASE 1"))
}

```

### Special Case 2: Non-circular, Equatorial Orbit

```{r}
# CASE 2
const6 <- e1>10e-11&i0<10e-11&i0>pi-10e-11
const6A <- e0[2] < 0
const6B <- pracma::cross(r0,v0) < 0
if (const6 == TRUE){
   Omega0 =  0                              # Eq. (3.15)
   omega0 = acos(e0[1]/e1)                  # Eq. (3.16)
   nu0 = acos(dot(e0,r0)/(e1*r1))           # Eq. (3.17)
  if (const6A == TRUE){  
       omega0 = 2*pi-omega0 
    if (const6B == TRUE){
      nu0 = 2*pi-nu0
      print(paste("-------------------------------"))
      print(paste("CASE 2"))
      print(paste("Omega =", Omega0))
      print(paste("Omega =", omega0))
      print(paste("Nu    =", nu0))
      }
    }
  } else {
  print(paste("Not CASE 2"))
  }

```

### Special Case 3: Circular, Inclined Orbit

```{r}
# CASE 3
const7 <- e1<10e-11&i0>=10e-11&i0<pi-10e-11
const7A <- n0[2] < 0
const7B <- r0[3] < 0
if (const6 == TRUE){
  Omega0 =  acos(n0[1]/n1)                  # Eq. (3.18)
  omega0 = 0                                # Eq. (3.19)   
  nu0 = acos(dot(n0,r0)/(n1*r1))            # Eq. (3.20)
  if (const7A == TRUE){  
       Omega0 = 2*pi-Omega0 
    if (const7B == TRUE){
      nu0 = 2*pi-nu0
      print(paste("-------------------------------"))
      print(paste("CASE 3"))
      print(paste("Omega =", Omega0))
      print(paste("Omega =", omega0))
      print(paste("Nu    =", nu0))
      }
    }
  } else {
  print(paste("Not CASE 3"))
  }

```

### Special Case 4: Circular, Equatorial Orbit

```{r}
# CASE 4
const8 <- e1<10e-11&i0<10e-11&i0>pi-10e-11
const8A <- r0[2] < 0
if (const8 == TRUE){
  Omega0 = 0                              # Eq. (3.21)
  omega0 = 0                              # Eq. (3.22)
  nu0 = acos(r0[1]/r1)                    # Eq. (3.23)
  if (const8A == TRUE){
    nu0 = 2*pi - nu0
    print(paste("Omega =", Omega0))
    print(paste("Omega =", omega0))
    print(paste("Nu    =", nu0))
  }
} else {
  print(paste("Not CASE 4"))
}

```

## 3.1.3 Keplerian Elements to Cartesian State

The transformation from the Keplerian elements to the Cartesian state is one of the most common state transformations in astrodynamics. We previously defined both state types and refer you to Tables 3.1 and 3.2 for their definitions. Below we show the algorithm to convert from the Keplerian elements to the Cartesian state.

Give: a, e, i, Omega, omega, nu, and µ,
Find: r and v

```{r}

#If |a(1−e)| < 0.001 then a singular conic section has been encountered while converting from the Keplerian elements to the Cartesian state. The radius of periapsis must be greater than 1 meter.

const1 <- abs(a0*(1-e1))<0.001
const2 <- 1+e1*cos(r1) < 1e-30
const3 <- abs(1-e1) < 1e-7 
const4 <- e1 > 1 & abs(vM)>=(pi-acos(1/e1))
if (const1 == TRUE){
  print("Warning: A nearly singular conic section was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const2 == TRUE){
    print("Warning: A near infinite radius was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const3 == TRUE){
  print("Warning: A nearly parabolic orbit was encountered while converting from the Keplerian elements to the Cartesian state. The Keplerian elements are undefined for a parabolic orbit.")
} else if (const4 == TRUE){
  limitTA = pi - acos(1/e1) # Eq. (3.24)
  print(paste("Error: The TA value is not physically possible for a hyperbolic orbit with the input values of SMA and ECC.The allowed values are: −", limitTA, "< TA <", limitTA, "(degrees)"))
} else {   
p0 = round(a0*(1 - e1^2)/1e+9,4) # Eq. (3.25)
radius = p0/(1+e1*cos(v1)) # Eq. (3.26)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))

}

```


```{r}

const1 <- abs(a0*(1-e1))<0.001

if (const1 == TRUE){
  print("Warning: A nearly singular conic section was encountered while converting from the Keplerian elements to the Cartesian state.")
} else {   
p0 = round(a0*(1 - e1^2)/1e+9,4)                              # Eq. (3.25)
radius = p0/(1+e1*cos(v1))                                    # Eq. (3.26)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))

}

```

```{r}
const1 <- abs(a0*(1-e1))<0.001
const2 <- 1+e1*cos(r1) < 1e-30

if (const1 == TRUE){
  print("Warning: A nearly singular conic section was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const2 == TRUE){
    print("Warning: A near infinite radius was encountered while converting from the Keplerian elements to the Cartesian state.")
} else {   
p0 = round(a0*(1 - e1^2)/1e+9,4)                              # Eq. (3.25)
radius = p0/(1+e1*cos(v1))                                    # Eq. (3.26)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))

}

```


```{r}

#If |a(1−e)| < 0.001 then a singular conic section has been encountered while converting from the Keplerian elements to the Cartesian state. The radius of periapsis must be greater than 1 meter.

const1 <- abs(a0*(1-e1))<0.001
const2 <- 1+e1*cos(GCRF_coordinates$velocity[2]) < 1e-30

if (const1 == TRUE){
  print("Warning: A nearly singular conic section was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const2 == TRUE){
    print("Warning: A near infinite radius was encountered while converting from the Keplerian elements to the Cartesian state.")
} else {   
p0 = round(a0*(1 - e1^2)/1e+9,4) # Eq. (3.25)
radius = p0/(1+e1*cos(v1)) # Eq. (3.26)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))

}

```

```{r}

const1 <- abs(a0*(1-e1))<0.00001
const2 <- abs(1+e1*cos(r1)) < 1e-11
const3 <- abs(1-e1) < 1e-7 

if (const1 == TRUE){
  print("Warning: A nearly singular conic section was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const2 == TRUE){
    print("Warning: A near infinite radius was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const3 == TRUE){
  print("Warning: A nearly parabolic orbit was encountered while converting from the Keplerian elements to the Cartesian state. The Keplerian elements are undefined for a parabolic orbit.")
} else {   
p0 = round(a0*(1 - e1^2)/1e+9,4)                              # Eq. (3.25)
radius = p0/(1+e1*cos(v1))                                    # Eq. (3.26)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))


}

```

```{r}

#If |a(1−e)| < 0.001 then a singular conic section has been encountered while converting from the Keplerian elements to the Cartesian state. The radius of periapsis must be greater than 1 meter.

const1 <- abs(a0*(1-e1))<0.001
const2 <- 1+e1*cos(r1) < 1e-30
const3 <- abs(1-e1) < 1e-7 
const4 <- e1 > 1 & abs(vM)>=(pi-acos(1/e1))
if (const1 == TRUE){
  print("Warning: A nearly singular conic section was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const2 == TRUE){
    print("Warning: A near infinite radius was encountered while converting from the Keplerian elements to the Cartesian state.")
} else if (const3 == TRUE){
  print("Warning: A nearly parabolic orbit was encountered while converting from the Keplerian elements to the Cartesian state. The Keplerian elements are undefined for a parabolic orbit.")
} else if (const4 == TRUE){
  limitTA = pi - acos(1/e1)                                   # Eq. (3.24)
  print(paste("Error: The TA value is not physically possible for a hyperbolic orbit with the input values of SMA and ECC.The allowed values are: −", limitTA, "< TA <", limitTA, "(degrees)"))
} else {   
p0 = round(a0*(1 - e1^2)/1e+9,4)                              # Eq. (3.25)
radius = p0/(1+e1*cos(v1))                                    # Eq. (3.26)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))


}

```


If 1 + e0*cos(v1) < 1e-10, then the following warning is displayed but computation proceeds. “Warning: The orbital radius is large in the conversion from Keplerian to Cartesian state and the state may be near a
singularity causing numerical errors in the conversion.”

The position components of the cartesian state vector are calculated using the following three equations.

```{r}
const9 <- (abs(p0) < 1e-30)
if(const9 == TRUE){
  print("Warning: The algorithm does not support parabolic orbits in conversion
from keplerian to cartesian elements.")
} else { 
x1 = (r1*(cos(omega0 + nu0)*cos(Omega0) - cos(i0)*sin(omega0 + nu0)*sin(Omega0)))/1 # Eq. (3.27)
y1 = (r1*(cos(omega0 + nu0))*sin(Omega0) + cos(i0)*sin(omega0 + nu0)*cos(Omega0))/1  # Eq. (3.28)
z1 = (r1*(sin(omega0 + nu0))*sin(i0))/1 # Eq. (3.29)
}

```

Before calculating the velocity components we check to ensure the orbit is not parabolic. This avoids another possible division by zero. If
(||p||<1e30), then error and return: “Warning: Cannot not support parabolic orbits in conversion from keplerian to cartesian elements”.

If the orbit is not parabolic, we continue and calculate the velocity components using

```{r}
help1 <- sqrt(mu/p0)*(cos(v1)+e1)
help2 <- (-sin(omega0)*cos(Omega0))-(cos(i0)*sin(Omega0)*cos(omega0))
help3 <- sqrt(mu/p0)*sin(nu0)
help4 <- (cos(omega0)*cos(Omega0))-(cos(i0)*sin(Omega0)*sin(omega0))
help5 <- (-sin(omega0)*sin(Omega0))-(cos(i0)*cos(Omega0)*cos(omega0))
help6 <- (cos(omega0)*sin(Omega0))-(cos(i0)*cos(Omega0)*sin(omega0))
help7 <- (cos(v1)+e1)
help8 <- (sin(i0)*cos(omega0) - sin(nu0)*sin(i0)*sin(omega0))

x_dot <- (help1*help2-help3*help4)/1 # Eq. (3.30)
y_dot <- (help1*help5-help3*help6)/1 # Eq. (3.31)
z_dot <- (sqrt(mu/p0)*(help7*help8))/1 # Eq. (3.32)

print(paste("semilatus rectum = ", p0, "(km)"))
print(paste("r = ", radius, "(km)"))
print(paste("x1 = ", x1, "(km)"))
print(paste("y1 = ", y1, "(km)"))
print(paste("z1 = ", z1, "(km)"))
print(paste("x_dot = ", x_dot, "(km)"))
print(paste("y_dot = ", y_dot, "(km)"))
print(paste("z_dot = ", z_dot, "(km)"))

```

```{r}
tab1 <- rbind(x1,y1,x1,x_dot, y_dot, z_dot)
tab3 <- cbind("Vector Components", "Value")
tab4 <- rbind("x comp of position", "y comp of position", "z comp of position", "x comp of velocity", "y comp of velocity", "z comp of velocity")
tab5 <- cbind(tab4, tab1)
rbind(tab3, tab5)

library(knitr) 
library(kableExtra) 
kable(tab5, col.names=c('Parameter', 'Values'), caption = "Orbital Parameters and Range of Values", align='r', booktabs = T) %>%
kable_styling(full_width = FALSE) %>%
column_spec(1, width = "8cm")

```


## Equinoctial Elements to Cartesian State
The equinoctial elements used in this algorithm are defined in Table 3.4. The algorithm to convert from equinoctial elements to the cartesian state was taken from the GTDS Mathematical Theory.

Given: a, h, k, p, q, λ, and µ

Find: "r"  and "v"

We begin by using the mean longitude, λ, to find the eccentric longitude F. The equation relating the two is transcendental:

$\lambda = F + h \cos{F} -k \sin{F}$


```{r}
M0=molniya$meanAnomaly*pi/180
h0 = as.matrix(e0*sin(omega0+Omega0))
h1 = norm(h0)
k0 = as.matrix(e0*cos(omega0+Omega0))
k1 = norm(k0)
n0 = pracma::cross(as.matrix(c(0,0,1)),h0)
n1 = norm(n0)
F0 = as.vector(a0*e0)
F0
l0 = Omega0+omega0+M0
print(paste("l0 =",l0))
lambda = F0+h0*cos(F0)-k0*sin(F0)
lambda

```

We use the Newton-Raphson method to solve for F, using λ as the initial guess. We iterate on the following equation until $|F(i + 1) − F(i)| < 10e−10$

$F(i+1)=F(i)-f(F)/(f'(F))$

where

$f(F) = F + h cos(F) − k sin(F) − λ$ (3.35)
$f′(F) = 1 − h sin(F) − k cos(F)$ (3.36)

```{r}
sprintf(x, fmt = '%#.3f') 
F1 <- geodetic_matrix[,2] # geodetic longitude component


fF = F0 + h1*cos(l0)-k1*sin(l0)-lambda  #Eq. (3.34)
fpF = 1- h1*sin(l0)-k1*cos(l0)        # Eq. (3.35)

fF0 = F0- fF/fpF  # Eq. (3.36)

f1 <- (as.matrix(fF0))


for (i in 1:2000) { 
  
    output <- F1[i]
    outout <-as.matrix(output)
    f1 = as.matrix(rbind(f1, output))
    # Change in concavity = local minimum
     if(output < 10e-10) {
      break
     }
}

nr = nrow(f1)
l0 = f1[nr-1]
print(paste("Optimal mean longitude =", l0/1000, "km"))

```
F[i]=-(geodetic_matrix[i,2] + h0*cos(geodetic_matrix[i,2]) - k0*sin(geodetic_matrix[i,2]) - lambda)/( 1 - h0*sin(geodetic_matrix[i,2]) - k0*cos(geodetic_matrix[i,2]))


```{r, warning = FALSE}

beta <- 1/(1+sqrt(abs(1-h1^2-k1^2))) # Eq. (3.37)
print(paste('beta = ', beta))

n1 <-sqrt(mu/abs(a0^2)) # Eq. (3.38)
print(paste('n0 = ', n1[1]))

r0 = a0*(1-k1*cos(l0)-h1*sin(l0))  # Eq. (3.39)
print(paste('r0 = ', r0))

X1=a0*((1-h1^2*beta)*cos(l0)+h1*k1*beta*sin(l0)-k1) # Eq. (3.40)
print(paste('X1 = ', X1))

Y1=a0*((1-k1^2*beta)*sin(l0)+h1*k1*beta*cos(l0)-h1) # Eq. (3.41)
print(paste('Y1 = ', Y1))

X1_dot=((n0*a0^2)/r1)*(h1*k1*beta*cos(l0)-(1-h1^2*beta)*sin(l0)) # Eq. (3.42)
print(paste('X1_dot = ', X1_dot))

Y1_dot=((n0*a0^2)/r1)*((1-k1^2*beta)*cos(l0)-h1*k1*beta*sin(l0)) # Eq. (3.43)
print(paste('Y1_dot = ', Y1_dot))
print("--------------------------------")
if (X1_dot == 0 & Y1_dot == 0){
  print("A change in concavity occures when X_dot=0 and y_dot=0, indicating a local oprtimal value")
}  else {
    print("The algorithm failed to converge")
}

```
Recall that a derivative represents the instantaneous change of the function. Regarding the position vector, an instantaneous change represents velocity. Hence, when the velocity reaches a value of zero, it has stopped for an instant (i.e., smaller than nanoseconds) and the point that is stops is a loccl maximum or minimum (using the Newton-Raphson method). Then we only need to check where the concavity of the orbity changes again, indicating we have found the second optimal values. Then its a a simple matter of comparing the coordinators of the points were the space object has stopped.


```{r}
f0=as.matrix(a0*e0)
g0=pracma::cross(h0,f0)

r0= X1*f0 + Y1*g0 # Eq. (3.44)
r0

v0=X1_dot*f0 + Y1_dot*g0 # Eq. (3.45)
v0

```

## Cartesian State to Equinoctial Elements

The equinoctial elements used here are defined in Table 3.4. The algorithm to convert from the cartesian state to the equinoctial elements was taken from the GTDS Mathematical Theory.

Given: "r" , "v" , and μ

Find: a, h, k, p, q, λ, and μ


```{r}
M0=molniya$meanAnomaly*pi/180
h0 = as.matrix(e0*sin(omega0+Omega0))
h1 = norm(h0)
k0 = as.matrix(e0*cos(omega0+Omega0))
k1 = norm(k0)
n0 = pracma::cross(as.matrix(c(0,0,1)),h0)
n1 = norm(n0)
F0 = as.vector(a0*e0)
F0
l0 = Omega0+omega0+M0
print(paste("l0 =",l0))
lambda = F0+h0*cos(F0)-k0*sin(F0)
lambda

```

The orbit eccentricity and energy are calculated using

```{r}
library(superml)
library(R6)
r0 <- as.matrix(GCRF_coordinates$position) #new_state1$position
v0 <- as.matrix(GCRF_coordinates$velocity) #new_state1$velocity

r1 = norm(r0)                   #Eq. (3.48)
v1 = norm(v0)                   #Eq. (3.49)

e0 <- as.matrix(((v1^2-mu/r1)*r0-dot(r0,v0)*v0)/mu)  #Eq. (3.50)
e1 = norm(e0)                   #Eq. (3.51)

xi = (v1^2/2)-(mu/r1)           #Eq. (3.52)

print(paste("r1 = ", r1))      
print(paste("v1 = ", v1))
print(paste("e1 = ", e1))
print(paste("xi = ", xi))

```

For parabolic orbits, the semimajor axis is infinite and the energy is zero. Here we check to see if the orbit is near parabolic. If |1-e|<10^(-7) an error message is reported and conversion is aborted.

The semimajor axis is computed using

```{r}
a0 <- -mu/(2*xi)                  #Eq. (3.53)
print(paste("a0 = ", a0))

```

Here we check to see if the conic section is nearly singular. If |a(1-	e)|< 0.001(km) then an error message is thrown and conversion is aborted.
The angular momentum unit vector is

```{r}
library(pracma)
h0 = cross(r0,v0)/norm(cross(r0,v0))   #Eq. (3.54)
print(paste("h1 = ",h0[1], "h2 = ",h0[2], "h3 = ",h0[3]))

```

The unit vectors that define the equinoctial coordinate system can be calculated using

```{r}
fx = 1-(h1[1]^2)/(1+h1[3])          #Eq. (3.55)
fy = (h1[1]*h1[2])/(1+ h1[3])       #Eq. (3.56)
fz = -h1[1]                         #Eq. (3.57)

print(paste("fx =", fx))
print(paste("fy =", fy))
print(paste("fz =", fz))

```


```{r}
g0=cross(h0,f0)       #Eq. (3.58)
print(paste("g1 =", g0[1], "g2 =",g0[2], "g3 =",g0[3]))

```

We now have the necessary information to calculate the elements h, k, p, and q using the following relationships.

```{r}
h1 = dot(e0,g0)       #Eq. (3.59)
k1 = dot(e0,f0)       #Eq. (3.60)

p = h0[1]/(1+h0[3])       #Eq. (3.61)
q = h0[2]/(1+h0[3])       #Eq. (3.62)

print(paste("h1 =", h1))
print(paste("k1 =", k1))
print(paste("p =", p))
print(paste("q =", q))

```

The final element to calculate is the mean longitude, λ. We begin by computing the eccentric longitude, F, using

```{r}
X1 = dot(r0,f0)       #Eq. (3.63)
Y1 = dot(r0,g0)       #Eq. (3.64)

print(paste("X1 =", X1))
print(paste("Y1 =", Y1))

```

```{r}
cosF = k1+(((1-k1^2*beta)*X1-h1*k1*beta*Y1)/(a0*sqrt(abs(1-h1^2-k1^2))))        #Eq. (3.65)
sinF = k1+(((1-h1^2*beta)*Y1-h1*k1*beta*X1)/(a0*sqrt(abs(1-h1^2-k1^2))))        #Eq. (3.66)
F_1 = atan(sinF/cosF)        #Eq. (3.67)

print(paste("cosF =", cosF))
print(paste("sinF =", sinF))
print(paste("F_1 =", F_1))

```

where β is given by Eq. 3.37. The mean longitude is computed using the generalized Kepler equation

```{r}
lambda = F_1 + h1*cos(F_1) - k1*sin(F_1)       #Eq. (3.68)
print(paste("lambda =", lambda))

```

## Cartesian State to SphericalAZFPA State

The spherical state, with azimuth, α_f, and flight path angle, ψ, is described in Table 3.5 and Fig. 3.2. The algorithm below shows how e we convert from the cartesian state to the spherical state with azimuth and flight path angle.

Given: "r"  and "v" 

Find: r, λ, δ, v, ψ, and α_f

We begin by calculating the right ascension λ, and the declination δ.

```{r}
r0 <- GCRF_coordinates$position #new_state1$position
v0 <- GCRF_coordinates$velocity #new_state1$velocity

r1 = norm(as.matrix(r0))                 #Eq. (3.69)
lambda = atan2(abs(r0[1]),abs(r0[2]))    #Eq. (3.70)
delta = asin(abs(r0[3])/r1)              #Eq. (3.71)

print(paste("r1 =", r1))
print(paste("lambda =", lambda))
print(paste("delta =", delta))

```

The magnitude of the velocity vector is simply

```{r}
v1 <- norm(as.matrix(v0))        #Eq. (3.72)
print(paste("v1 =", v1))

```

We calculate the vertical flight path angle, psi, using

```{r}
psi <- acos(dot(r0,v0)/(r1*v1))     #Eq. (3.73)
print(paste("psi =", psi))

```

To calculate the azimuth angle, αz, we begin by calculating the rotation matrix from the frame in which the cartesian state is expressed in, Fi, to a local frame, Fℓ, where ˆz is a unit vector that points north. The basis vectors of Fℓ expressed in Fi can be calculated using

```{r}
x_hat=as.matrix(rbind(cos(delta)*cos(lambda),cos(delta)*sin(lambda),sin(delta))) #Eq. (3.74)

y_hat=as.matrix(rbind(cos(lambda+pi/2),sin(lambda+pi/2),0)) #Eq. (3.75)

z_hat=as.matrix(rbind(-sin(delta)*cos(lambda),-sin(delta)*sin(lambda),cos(delta)))  #Eq. (3.76)

print(paste("x_hatx =", x_hat[1], "x_haty =", x_hat[2], "x_hatz =", x_hat[3]))
print(paste("y_hatx =", y_hat[1], "x_haty =", x_hat[2], "y_hatz =", x_hat[3]))
print(paste("z_hatx =", z_hat[1], "x_haty =", x_hat[2], "z_hatz =", x_hat[3]))

```

We can write the tranformation matrix that goes from Fi to Fℓ, Rℓi, as

```{r}
R_li <- t(as.matrix(x_hat,y_hat,z_hat))  #Eq. (3.77)
print(paste("R_li =", R_li))

```

The velocity in the local frame, v′, can be written as
v′ = Rℓiv

```{r}
v_prime<- R_li*v0                     #Eq. (3.78)
print(paste("v_prime =", v_prime))

```

Finally, we calculate the azimuth angle using

```{r}
a_f = atan2(v_prime[2],v_prime[3])   #Eq. (3.79)
print(paste("a_f =", a_f))

```

## SphericalAZFPA State to Cartesian State
In this section we present the algorithm used to convert from the spherical state (with ψ and α_f) to the cartesian state.

Given: r, λ, δ, v, ψ, and α_f

Find: "r"  and "v" 

The components of the position vector are calculated using

```{r}
x1=r1*cos(delta)*cos(lambda)	  # Eq.(3.80)
y1=r1*cos(delta)*sin(lambda) 	# Eq.(3.81)
z1=r1*sin(delta)	        # Eq.(3.82)

print(paste("x1 =", x1))
print(paste("y1 =", y1))
print(paste("z1 =", z1))

```

We can write the velocity vector in terms of v, ψ, and αf as,

```{r}
v0 = v1*(cos(psi)*x_hat+sin(psi)*sin(a_f)*y_hat+sin(psi)*cos(a_f)*z_hat) # Eq. (3.83)
print(paste("v0 =", v0))

```

where, $\hat{x}$, $\hat{y}$, and $\hat{z}$ are given in Eqs. (3.74), (3.75), and (3.76) respectively. Breaking down Eq. (3.83) into
components gives us

```{r}
vx = v1*(cos(psi)*cos(delta)*cos(lambda)-sin(psi)*(sin(a_f)*sin(lambda)
+cos(a_f)*sin(delta)*cos(lambda)))
# Eq. (3.84)
vy = v1*(cos(psi)*cos(delta)*sin(lambda)+sin(psi)*(sin(a_f)*cos(lambda)
-cos(a_f)*sin(delta)*sin(lambda)))
# Eq. (3.85)
vz = v1*(cos(psi)*sin(delta)+sin(psi)*cos(a_f)*cos(delta)) # Eq. (3.86)

print(paste("vx =", vx))
print(paste("vy =", vy))
print(paste("vz =", vz))

```

## Cartesian State to SphericalRADEC State

The conversion form the Cartesian state to the spherical state with right ascension of velocity, λv, and declination of velocity, δv, is very similar to the transformation shown in Sec. 3.1.6. The algorithm to calculate λv and δv is shown below.

Given: r and v

Find: r, λ, δ, v, λv, and δv

To calculate r, λ, δ, and v we use Eqs. (3.69), (3.70), (3.71), and (3.72) respectively. The right ascension of velocity, λv, and declination of velocity, δv, are calculated using

```{r}
lambda_v = atan2(vy,vz)
delta_v = asin(vz/v1)
print(paste("lambda_v =", lambda_v))
print(paste("delta_v =", delta_v))

```

In the next section, we show the the transformation from the spherical state with right ascension of velocity, λv, and declination of velocity, δv, to the cartesian state.

## SphericalRADEC State to Cartesian State
This transformation is similar to the conversion presented in Sec 3.1.7. The primary difference is how the velocity is represented.

Given: r, λ, δ, v, λv, and δv

Find: r and v

The position components are calculated using Eqs. (3.80), (3.81), and (3.82). The velocity components are calculated using

```{r}
vx = v1*cos(lambda_v)*cos(delta_v) # Eq. (3.89)
vy = vx*tan(lambda_v) # Eq. (3.90)
vz = v1*sin(delta_v) # Eq. (3.91)

print(paste("vx =", vx))
print(paste("vy =", vy))
print(paste("vz =", vz))

```

In the last few subsections, we have looked at transformations involving the spherical elements. Now let’s look at transformations involving the modified Keplerian elements.


Consider an orbiting LEO object in a prograde equatorial orbit, with eccentricity 0.01 andorbital period 99.5 minutes, and whose initial state in Cartesian ECI coordinates is uncertain, with standard deviation = 1 km for each location coordinate and 0.005 km/sec for each velocity coordinate, where the uncertainties in all 6 coordinates are independent. These initial uncertainties are realistic and moderate.
The state of the object has been propagated for 2.09 days (approximately 30.25 orbits for the central state). Propagated point clouds have represented as 6-dimensional pairs plot in Cartesian ECI (Fig. 1), Keplerian (Fig. 2) and Equinoctial (Fig. 3) coordinates. For all the examples we use N = 2000 data points to generate the point cloud. This value suffices to visualize key features in the pairs plots such as skewness, outliers, and approximate Gaussianity.


```{r}
mu = 3.986004418e14 # gravitational parameter
vM = 0.05*pi # between -Pi and +Pi
r0 <- GCRF_coordinates$position #new_state1$position
v0 <- GCRF_coordinates$velocity #new_state1$velocity
h0 = pracma::cross(r0,v0) # h vector cross product;    Eq. (3.1)
# all five norm type are the same for vectors
h1 = norm(as.matrix(h0))                     # Eq. (3.2)
hz = h0[3]
i0 = acos(hz/h1)
id3 = as.vector(c(0,0,1))
n0 = pracma::cross(id3, h0)                          # Eq. (3.3) 
vM = 0.05*pi # between -Pi and +Pi
r0 <- GCRF_coordinates$position #new_state1$position
v0 <- GCRF_coordinates$velocity #new_state1$velocity
h0 = pracma::cross(r0,v0) # h vector cross product;    Eq. (3.1)
# all five norm type are the same for vectors
h1 = norm(as.matrix(h0))                     # Eq. (3.2)
hz = h0[3]
i0 = acos(hz/h1)
id3 = as.vector(c(0,0,1))
                          
```

## Orbit Simulation Parameters

```{r}
set.seed(42)
g = 6.67*10^(-11)
gen_some_data = function(n_obs = 50) {
  datetime = "2022-09-12 0:33:42.8348159988855"
  mu = 3.986004418e14 # gravitational parameter
  int_designator = seq(0, 10, length.out = n_obs)
  eccentricity = runif(n = n_obs, min = 0, max = .9)
  focal_param = round(runif(n = n_obs, min = 100, max = 400),4)
  semi_latus_rectum = focal_param*eccentricity  
  semimajor_axis = semi_latus_rectum/abs((1-eccentricity^2))
  classification = sample(c("U", "C", "S"),size=n_obs,replace=TRUE)
  periapsis  = round(runif(n = n_obs, min = 0, max = 360), 4)
  inclination = round(runif(n = n_obs, min = 0, max = 180), 4)
  mean_motion = 360/focal_param
  mean_anomoly <- runif(n = n_obs, min = 0, max = 24) 
  pos_y <- round(runif(n = n_obs, min = -1000, max = 1000),4)
  pos_z <- round(runif(n = n_obs, min = -1000, max = 1000),4)
  acos(dot(n0,e0)/(n1*e1))
  OMEGA0 <- 80.0121*pi/round(runif(n = n_obs, min = 180, max = 360), 4)  
  nu = round(runif(n = n_obs, min = 0, max = 360), 4)
  longitudePerigee <- OMEGA0 + omega0
  trueLongitude <- longitudePerigee + nu
  day = round(runif(n = n_obs, min = 0, max = 24), 4)
  Bstar <- 0.66816e-4 # drag coefficient
  data.frame(mean_motion, semimajor_axis, semi_latus_rectum, eccentricity, periapsis, mean_anomoly, inclination, omega0, OMEGA0, trueLongitude, longitudePerigee, Bstar, datetime)
}

```

# Calculation of the orbital period
#2*pi/n0

```{r, warning = FALSE}
set.seed(123)
orb_data = gen_some_data(n_obs = 5000)
orb_tst = gen_some_data(n_obs = 800)
orb_trn = gen_some_data(n_obs = 400)
summary(orb_trn)
```

## Test

```{r}
orb_trn <- as.data.frame(orb_trn)
orb_trn

```

## Eccentricity

```{r}
targetTimes <- seq(0, 4000, by=5)
sat1<-test_TLEs[[7]]


results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=2.285378*((2*pi)/(1440)),
                        e0=0.0,
                        i0=46.7916*pi/180,
                        M0=10.4117*pi/180,
                        omega0=47.4722*pi/180,
                        OMEGA0=230.4354*pi/180,
                        Bstar=0.014311,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=2.285378*((2*pi)/(1440)),
                        e0=0.3,
                        i0=46.7916*pi/180,
                        M0=10.4117*pi/180,
                        omega0=47.4722*pi/180,
                        OMEGA0=230.4354*pi/180,
                        Bstar=0.014311,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=2.285378*((2*pi)/(1440)),
                        e0=0.6,
                        i0=46.7916*pi/180,
                        M0=10.4117*pi/180,
                        omega0=47.4722*pi/180,
                        OMEGA0=230.4354*pi/180,
                        Bstar=0.014311,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=2.285378*((2*pi)/(1440)),
                        e0=0.9,
                        i0=46.7916*pi/180,
                        M0=10.4117*pi/180,
                        omega0=47.4722*pi/180,
                        OMEGA0=230.4354*pi/180,
                        Bstar=0.014311,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```


```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Eccentricity = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Eccentricity = 0.3',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Eccentricity = 0.6',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Eccentricity = 9.9',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")

```

### Eccentricity Ground-Tracks

```{r}

dateTime1 <- sat1$dateTime
dateTime2 <- sat1$dateTime
dateTime3 <- sat1$dateTime
dateTime4 <- sat1$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```

## Inclination

```{r}
targetTimes <- seq(0, 4000, by=5)
sat1<-test_TLEs[[7]]


results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=0.006971845,
                        e0=0,
                        i0=0,
                        M0=0,
                        omega0=0,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=0.006971845,
                        e0=0.0,
                        i0=63.4,
                        M0=0,
                        omega0=0,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=0.006971845,
                        e0=0.0,
                        i0=80,
                        M0=0,
                        omega0=0,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=0.006971845,
                        e0=0.0,
                        i0=180,
                        M0=0,
                        omega0=0,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```


```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Inclination = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 15',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 30',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 45',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")

```

### Inclination Ground-Tracks

```{r}
dateTime1 <- sat1$dateTime
dateTime2 <- sat1$dateTime
dateTime3 <- sat1$dateTime
dateTime4 <- sat1$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```


============================================================

## Mean Anomaly

```{r}
#getLatestSpaceData (targets="all")
explorer_lines <- c("VANGUARD",
"1 00016U 58002A   22266.39408941 -.00000059  00000-0 -67090-4 0  9990",
"2 00016  34.2626 283.8544 2026875 128.9439 250.9929 10.48817812545765")

explorer_TLE <- parseTLElines(explorer_lines)
explorer_TLE

```

## Orbit Type Comparison

```{r, warning=FALSE}
meoTLEs <- readTLE(paste0(path.package("asteRisk"), "/newTLE.txt"))
heoTLEs <- readTLE(paste0(path.package("asteRisk"), "/heoTLE.txt"))
geoTLEs <- readTLE(paste0(path.package("asteRisk"), "/geoTLE.txt"))
leoTLEs <- readTLE(paste0(path.package("asteRisk"), "/leoTLE.txt"))

sat1 <- meoTLEs[[19]]
sat2 <- leoTLEs[[13]]
sat3 <- heoTLEs[[41]]
sat4 <- geoTLEs[[60]]

print(paste("Object Name:  ", sat1$objectName))
print(paste("Launch Year:  ", sat1$launchYear))
print(paste("Mean Motion:  ", sat1$meanMotion))
print(paste("Mean Anomaly: ", sat1$meanAnomaly))
print(paste("Eccentricity: ", sat1$eccentricity))
print(paste("Ascension:    ", sat1$ascension))
print(paste("Inclination:  ", sat1$inclination))
print(paste("Perigee Arg:  ", sat1$perigeeArgument))
print(paste("B-star:       ", sat1$Bstar))
print(paste("Obital Period:", 1/sat1$meanMotion))
print(paste("Observ Period:", round(i/sat1$meanMotion,0)))
print(paste("------------------------------------"))
print(paste("Object Name:  ", sat2$objectName))
print(paste("Launch Year:  ", sat2$launchYear))
print(paste("Mean Motion:  ", sat2$meanMotion))
print(paste("Mean Anomaly: ", sat2$meanAnomaly))
print(paste("Eccentricity: ", sat2$eccentricity))
print(paste("Ascension:    ", sat2$ascension))
print(paste("Inclination:  ", sat2$inclination))
print(paste("Perigee Arg:  ", sat2$perigeeArgument))
print(paste("B-star:       ", sat2$Bstar))
print(paste("Obital Period:", 1/sat2$meanMotion))
print(paste("Observ Period:", round(i/sat2$meanMotion,0)))
print(paste("------------------------------------"))
print(paste("Object Name:  ", sat3$objectName))
print(paste("Launch Year:  ", sat3$launchYear))
print(paste("Mean Motion:  ", sat3$meanMotion))
print(paste("Mean Anomaly: ", sat3$meanAnomaly))
print(paste("Eccentricity: ", sat3$eccentricity))
print(paste("Ascension:    ", sat3$ascension))
print(paste("Inclination:  ", sat3$inclination))
print(paste("Perigee Arg:  ", sat3$perigeeArgument))
print(paste("B-star:       ", sat3$Bstar))
print(paste("Obital Period:", 1/sat3$meanMotion))
print(paste("Observ Period:", round(i/sat3$meanMotion,0)))
print(paste("------------------------------------"))
print(paste("Object Name:  ", sat4$objectName))
print(paste("Launch Year:  ", sat4$launchYear))
print(paste("Mean Motion:  ", sat4$meanMotion))
print(paste("Mean Anomaly: ", sat4$meanAnomaly))
print(paste("Eccentricity: ", sat4$eccentricity))
print(paste("Ascension:    ", sat4$ascension))
print(paste("Inclination:  ", sat4$inclination))
print(paste("Perigee Arg:  ", sat4$perigeeArgument))
print(paste("B-star:       ", sat4$Bstar))
print(paste("Obital Period:", 1/sat4$meanMotion))
print(paste("Observ Period:", round(i/sat4$meanMotion,0)))

```


```{r}
targetTimes <- seq(0, 3000, by=5)

results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=sat1$meanMotion*((2*pi)/(1440)),
                        e0=sat1$eccentricity,
                        i0=	sat1$inclination*pi/180,
                        M0=sat1$meanAnomaly*pi/180,
                        omega0=sat1$perigeeArgument*pi/180,
                        OMEGA0=sat1$ascension*pi/180,
                        Bstar=sat1$Bstar,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=sat2$meanMotion*((2*pi)/(1440)),
                        e0=sat2$eccentricity,
                        i0=	sat2$inclination*pi/180,
                        M0=sat2$meanAnomaly*pi/180,
                        omega0=sat2$perigeeArgument*pi/180,
                        OMEGA0=sat2$ascension*pi/180,
                        Bstar=sat2$Bstar,
                        initialDateTime=sat2$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=sat3$meanMotion*((2*pi)/(1440)),
                        e0=sat3$eccentricity,
                        i0=	sat3$inclination*pi/180,
                        M0=sat3$meanAnomaly*pi/180,
                        omega0=sat3$perigeeArgument*pi/180,
                        OMEGA0=sat3$ascension*pi/180,
                        Bstar=sat3$Bstar,
                        initialDateTime=sat3$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=sat4$meanMotion*((2*pi)/(1440)),
                        e0=sat4$eccentricity,
                        i0=	sat4$inclination*pi/180,
                        M0=sat4$meanAnomaly*pi/180,
                        omega0=sat4$perigeeArgument*pi/180,
                        OMEGA0=sat4$ascension*pi/180,
                        Bstar=sat4$Bstar,
                        initialDateTime=sat4$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")


print(paste("Satellite 1 Name:",sat1$objectName))
last_orb_propagation1
print(paste("Satellite 2 Name:",sat2$objectName))
last_orb_propagation2
print(paste("Satellite 3 Name:",sat3$objectName))
last_orb_propagation3
print(paste("Satellite 4 Name:",sat4$objectName))
last_orb_propagation4

```


```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Inclination = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 15',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 30',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 45',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")

```

## Ground-Tracks

```{r}
new_dateTime <- "2006-06-25 12:33:43"

dateTime1 <- sat1$dateTime
dateTime2 <- sat2$dateTime
dateTime3 <- sat3$dateTime
dateTime4 <- sat4$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```


============================================================

## Perigee Argument

```{r}
targetTimes <- seq(0, 3000, by=5)
sat1<-test_TLEs[[7]]


results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=0.006971845,
                        e0=0,
                        i0=0,
                        M0=0,
                        omega0=15,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=0.006971845,
                        e0=0.0,
                        i0=5,
                        M0=0,
                        omega0=45,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=0.006971845,
                        e0=0.0,
                        i0=180,
                        M0=0,
                        omega0=90,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=0.006971845,
                        e0=0.6,
                        i0=63.4,
                        M0=40,
                        omega0=140,
                        OMEGA0=190,
                        Bstar=0.02,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```


```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Inclination = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 15',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 30',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 45',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")

```

## Perigee Argument Ground-Tracks

```{r}
dateTime1 <- sat1$dateTime
dateTime2 <- sat1$dateTime
dateTime3 <- sat1$dateTime
dateTime4 <- sat1$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```

## Ascension

```{r}
targetTimes <- seq(0, 3000, by=5)
sat1<-test_TLEs[[7]]


results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=0.006971845,
                        e0=0.2,
                        i0=5,
                        M0=0,
                        omega0=45,
                        OMEGA0=0,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=0.006971845,
                        e0=0.2,
                        i0=5,
                        M0=0,
                        omega0=45,
                        OMEGA0=30,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=0.006971845,
                        e0=0.23,
                        i0=5,
                        M0=0,
                        omega0=45,
                        OMEGA0=180,
                        Bstar=0,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=0.009971845,
                        e0=0.2,
                        i0=5,
                        M0=0,
                        omega0=45,
                        OMEGA0=300,
                        Bstar=0.001,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```


```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Inclination = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 15',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 30',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 45',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")

```

## Ascension Ground-Tracks

```{r}
dateTime1 <- sat1$dateTime
dateTime2 <- sat1$dateTime
dateTime3 <- sat1$dateTime
dateTime4 <- sat1$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```


============================================================

## Orbit Type Comparison

```{r, warning=FALSE}
meoTLEs <- readTLE(paste0(path.package("asteRisk"), "/newTLE.txt"))
heoTLEs <- readTLE(paste0(path.package("asteRisk"), "/heoTLE.txt"))
geoTLEs <- readTLE(paste0(path.package("asteRisk"), "/geoTLE.txt"))
leoTLEs <- readTLE(paste0(path.package("asteRisk"), "/leoTLE.txt"))

sat1 <- meoTLEs[[2]]
sat2 <- leoTLEs[[13]]
sat3 <- heoTLEs[[41]]
sat4 <- geoTLEs[[60]]

print(paste("Object Name:  ", sat1$objectName))
print(paste("Launch Year:  ", sat1$launchYear))
print(paste("Mean Motion:  ", sat1$meanMotion))
print(paste("Mean Anomaly: ", sat1$meanAnomaly))
print(paste("Eccentricity: ", sat1$eccentricity))
print(paste("Ascension:    ", sat1$ascension))
print(paste("Inclination:  ", sat1$inclination))
print(paste("Perigee Arg:  ", sat1$perigeeArgument))
print(paste("B-star:       ", sat1$Bstar))
print(paste("Obital Period:", 1/sat1$meanMotion))
print(paste("Observ Period:", round(i/sat1$meanMotion,0)))
print(paste("------------------------------------"))
print(paste("Object Name:  ", sat2$objectName))
print(paste("Launch Year:  ", sat2$launchYear))
print(paste("Mean Motion:  ", sat2$meanMotion))
print(paste("Mean Anomaly: ", sat2$meanAnomaly))
print(paste("Eccentricity: ", sat2$eccentricity))
print(paste("Ascension:    ", sat2$ascension))
print(paste("Inclination:  ", sat2$inclination))
print(paste("Perigee Arg:  ", sat2$perigeeArgument))
print(paste("B-star:       ", sat2$Bstar))
print(paste("Obital Period:", 1/sat2$meanMotion))
print(paste("Observ Period:", round(i/sat2$meanMotion,0)))
print(paste("------------------------------------"))
print(paste("Object Name:  ", sat3$objectName))
print(paste("Launch Year:  ", sat3$launchYear))
print(paste("Mean Motion:  ", sat3$meanMotion))
print(paste("Mean Anomaly: ", sat3$meanAnomaly))
print(paste("Eccentricity: ", sat3$eccentricity))
print(paste("Ascension:    ", sat3$ascension))
print(paste("Inclination:  ", sat3$inclination))
print(paste("Perigee Arg:  ", sat3$perigeeArgument))
print(paste("B-star:       ", sat3$Bstar))
print(paste("Obital Period:", 1/sat3$meanMotion))
print(paste("Observ Period:", round(i/sat3$meanMotion,0)))
print(paste("------------------------------------"))
print(paste("Object Name:  ", sat4$objectName))
print(paste("Launch Year:  ", sat4$launchYear))
print(paste("Mean Motion:  ", sat4$meanMotion))
print(paste("Mean Anomaly: ", sat4$meanAnomaly))
print(paste("Eccentricity: ", sat4$eccentricity))
print(paste("Ascension:    ", sat4$ascension))
print(paste("Inclination:  ", sat4$inclination))
print(paste("Perigee Arg:  ", sat4$perigeeArgument))
print(paste("B-star:       ", sat4$Bstar))
print(paste("Obital Period:", 1/sat4$meanMotion))
print(paste("Observ Period:", round(i/sat4$meanMotion,0)))

```


```{r}
targetTimes <- seq(0, 3000, by=5)

results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=sat1$meanMotion*((2*pi)/(1440)),
                        e0=sat1$eccentricity,
                        i0=	sat1$inclination*pi/180,
                        M0=sat1$meanAnomaly*pi/180,
                        omega0=sat1$perigeeArgument*pi/180,
                        OMEGA0=sat1$ascension*pi/180,
                        Bstar=sat1$Bstar,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=sat2$meanMotion*((2*pi)/(1440)),
                        e0=sat2$eccentricity,
                        i0=	sat2$inclination*pi/180,
                        M0=sat2$meanAnomaly*pi/180,
                        omega0=sat2$perigeeArgument*pi/180,
                        OMEGA0=sat2$ascension*pi/180,
                        Bstar=sat2$Bstar,
                        initialDateTime=sat2$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=sat3$meanMotion*((2*pi)/(1440)),
                        e0=sat3$eccentricity,
                        i0=	sat3$inclination*pi/180,
                        M0=sat3$meanAnomaly*pi/180,
                        omega0=sat3$perigeeArgument*pi/180,
                        OMEGA0=sat3$ascension*pi/180,
                        Bstar=sat3$Bstar,
                        initialDateTime=sat3$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=sat4$meanMotion*((2*pi)/(1440)),
                        e0=sat4$eccentricity,
                        i0=	sat4$inclination*pi/180,
                        M0=sat4$meanAnomaly*pi/180,
                        omega0=sat4$perigeeArgument*pi/180,
                        OMEGA0=sat4$ascension*pi/180,
                        Bstar=sat4$Bstar,
                        initialDateTime=sat4$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```


```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Inclination = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 15',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 30',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 45',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")

```

## Ground-Tracks

```{r}

dateTime1 <- sat1$dateTime
dateTime2 <- sat2$dateTime
dateTime3 <- sat3$dateTime
dateTime4 <- sat4$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```


============================================================


## Validation using TLE Test Cases

### Original STR#3 SGP4 Test (sat#7)
We use NORAD Catalog Number 11801 to validate the SGP4 propogator model. Note that for this satellite, the SGDP4 automatically selects the SGP4 model as the appropriate propagator.

### NORAD Cat Num	11801 (SGD4 Propagator)

```{r}
#getLatestSpaceData (targets="all")
targetTimes <- seq(0, 600, by=1)

test_TLEs <- readTLE(paste0(path.package("asteRisk"), "/testTLE.txt"))
str3.3<-test_TLEs[[3]]
results_position_matrix3.3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3.3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result <- sgdp4(n0=str3.3$meanMotion*((2*pi)/(1440)),
                        e0=str3.3$eccentricity,
                        i0=str3.3$inclination*pi/180,
                        M0=str3.3$meanAnomaly*pi/180,
                        omega0=str3.3$perigeeArgument*pi/180,
                        OMEGA0=str3.3$ascension*pi/180,
                        Bstar=str3.3$Bstar,
                        initialDateTime=str3.3$dateTime, targetTime = targetTimes[i])
    results_position_matrix3.3[i,] <- new_result[[1]]
    results_velocity_matrix3.3[i,] <- new_result[[2]]
}
last_orb_propagation3.3 <- new_result
results_position_matrix3.3 = cbind(results_position_matrix3.3, targetTimes)
colnames(results_position_matrix3.3) <- c("x", "y", "z", "time")
last_orb_propagation3.3

```

### NORAD Cat Num	11801 Orbital Parameters

```{r}
library(tidyr)
col1 <- rbind("Object Name","NORAD Cat Num","Mean Motion", "Inclination", "Eccentricity","Mean Anomaly","Perigee Argument","Right Ascension","Bstar","Date-Time")
col2 <- rbind(str3.3$objectName,str3.3$NORADcatalogNumber, str3.3$meanMotion, str3.3$eccentricity, str3.3$inclination, str3.3$meanAnomaly, str3.3$perigeeArgument, str3.3$ascension, str3.3$Bstar, str3.3$dateTime)
tb1 <- cbind(col1,col2)
knitr::kable(tb1)
```


## NORAD Cat Num	11801 Orbit Plot

```{r}
out<-as.data.frame(results_position_matrix3.3)
p <- plot_ly(
     out, x = out$x, y = out$y, z = out$z, sizess = c(1,1),
     color = 'red', colors = c('aquamarine', 'dodgerblue')) %>%
     add_markers() %>%
     layout(
         scene = list(xaxis = list(title = 'x position'),
                      yaxis = list(title = 'y position'),
                      zaxis = list(title = 'z position'))
     ) 
p

```


### TEME to LATLON Geodetic

```{r}

dateTime3.3 <- str3.3$dateTime

ITRF_coordinates <- TEMEtoITRF(last_orb_propagation3.3$position,
                               last_orb_propagation3.3$velocity,
                               dateTime3.3)

geodetic_matrix3.3 <- matrix(nrow=nrow(results_position_matrix3.3), ncol=3)

for(i in 1:nrow(geodetic_matrix3.3)) {
    new_dateTime <- as.character(as.POSIXct(dateTime3.3, tz="UTC") + 60*targetTimes[i])
    new_geodetic <- TEMEtoLATLON(results_position_matrix3.3[i, 1:3]*1000,
                                 new_dateTime)
    geodetic_matrix3.3[i,] <- new_geodetic
}
colnames(geodetic_matrix3.3) <- c("latitude", "longitude", "altitude")

```

### NORAD Cat Num	11801 Ground Track

```{r}
library(ggmap)

ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) +
    geom_point(data=as.data.frame(geodetic_matrix3.3), aes(x=longitude, y=latitude),
             color="blue", size=1, alpha=0.8)

```

### NORAD Cat Num	11801 State Vectors

```{r}
out1 <- as.data.frame(results_position_matrix3.3)
out2 <- as.data.frame(results_velocity_matrix3.3)
chk <- cbind(out1,out2)
c1<-sprintf(chk[1,], fmt = '%#.9f')
c2<-sprintf(chk[121,], fmt = '%#.9f')
c3<-sprintf(chk[241,], fmt = '%#.9f')
c4<-sprintf(chk[361,], fmt = '%#.9f')
c5<-sprintf(chk[481,], fmt = '%#.9f')
c6<-sprintf(chk[601,], fmt = '%#.9f')
c7<-sprintf(chk[721,], fmt = '%#.9f')
c8<-sprintf(chk[841,], fmt = '%#.9f')
c9<-sprintf(chk[961,], fmt = '%#.9f')
c10<-sprintf(chk[1081,], fmt = '%#.9f')
c11<-sprintf(chk[1201,], fmt = '%#.9f')
c12<-sprintf(chk[1321,], fmt = '%#.9f')
c13<-sprintf(chk[1441,], fmt = '%#.9f')
c14<-sprintf(chk[1561,], fmt = '%#.9f')
c15<-sprintf(chk[1681,], fmt = '%#.9f')
c16<-sprintf(chk[1801,], fmt = '%#.9f')
df1<-as.data.frame(rbind(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16))
df2<-data.frame(sprintf(df1$V4,fmt='%.5s'),df1$V1,df1$V2,df1$V3,df1$V5,df1$V6,df1$V7)
colnames(df2) <- c("time", "x", "y" ,"z","V1", "V2", "V3")
df2

```

### Original STR#3 SDP4 Test (sat#5)
We use NORAD Catalog Number 09880 to validate the SDP4 propagator model. Note that for this satellite, the SGDP4 automatically selects the SDP4 model as the appropriate propagator.

### NORAD Cat Num	09880 (SDP4 Propagator)

```{r}
library(asteRiskData)
#getLatestSpaceData (targets="all")
targetTimes <- seq(0, 1200, by=5)

test_TLEs <- readTLE(paste0(path.package("asteRisk"), "/testTLE.txt"))
str3.5<-test_TLEs[[5]]
results_position_matrix3.5 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3.5 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result <- sgdp4(n0=str3.5$meanMotion*((2*pi)/(1440)),
                        e0=str3.5$eccentricity,
                        i0=str3.5$inclination*pi/180,
                        M0=str3.5$meanAnomaly*pi/180,
                        omega0=str3.5$perigeeArgument*pi/180,
                        OMEGA0=str3.5$ascension*pi/180,
                        Bstar=str3.5$Bstar,
                        initialDateTime=str3.5$dateTime, targetTime = targetTimes[i])
    results_position_matrix3.5[i,] <- new_result[[1]]
    results_velocity_matrix3.5[i,] <- new_result[[2]]
}
last_orb_propagation3.5 <- new_result
results_position_matrix3.5 = cbind(results_position_matrix3.5, targetTimes)
last_orb_propagation3.5

colnames(results_position_matrix3.5) <- c("x", "y", "z", "time")

```

### NORAD Cat Num	09880 Orbital Parameters

```{r}
col1 <- rbind("Object Name","NORAD Cat Num","Mean Motion", "Inclination","Eccentricity","Mean Anomaly","Perigee Argument","Right Ascension","Bstar","Date-Time")
col2 <- rbind(str3.5$objectName,str3.5$NORADcatalogNumber, str3.5$meanMotion, str3.5$eccentricity, str3.5$inclination, str3.5$meanAnomaly, str3.5$perigeeArgument, str3.5$ascension, str3.5$Bstar, str3.5$dateTime)
tb2 <- cbind(col1,col2)
knitr::kable(tb2)

```


### NORAD Cat Num	09880 Orbit Plot

```{r}
out<-as.data.frame(results_position_matrix3.5)
p <- plot_ly(
     out, x = out$x, y = out$y, z = out$z, sizess = c(1,1),
     color = 'red', colors = c('aquamarine', 'dodgerblue')) %>%
     add_markers() %>%
     layout(
         scene = list(xaxis = list(title = 'x position'),
                      yaxis = list(title = 'y position'),
                      zaxis = list(title = 'z position'))
     ) 
p
```


### TEME to LATLON Geodetic

```{r}

dateTime3.5 <- str3.5$dateTime

ITRF_coordinates <- TEMEtoITRF(last_orb_propagation3.5$position,
                               last_orb_propagation3.5$velocity,
                               dateTime3.5)

geodetic_matrix3.5 <- matrix(nrow=nrow(results_position_matrix3.5), ncol=3)

for(i in 1:nrow(geodetic_matrix3.5)) {
    new_dateTime <- as.character(as.POSIXct(dateTime3.5, tz="UTC") + 60*targetTimes[i])
    new_geodetic <- TEMEtoLATLON(results_position_matrix3.5[i, 1:3]*1000,
                                 new_dateTime)
    geodetic_matrix3.5[i,] <- new_geodetic
}
colnames(geodetic_matrix3.5) <- c("latitude", "longitude", "altitude")

```

### NORAD Cat Num	09880 Ground Track

```{r}
library(ggmap)

ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) +
    geom_point(data=as.data.frame(geodetic_matrix3.5), aes(x=longitude, y=latitude), 
             color="blue", size=0.3, alpha=0.8)

```

### NORAD Cat Num	09880 State Vectors 

```{r}

out1 <- as.data.frame(results_position_matrix3.5)
out2 <- as.data.frame(results_velocity_matrix3.5)
chk2 <- cbind(out1,out2)

d1<-sprintf(chk2[1,], fmt = '%#.9f')
d2<-sprintf(chk2[25,], fmt = '%#.9f')
d3<-sprintf(chk2[49,], fmt = '%#.9f')
d4<-sprintf(chk2[73,], fmt = '%#.9f')
d5<-sprintf(chk2[97,], fmt = '%#.9f')
d6<-sprintf(chk2[121,], fmt = '%#.9f')
d7<-sprintf(chk2[145,], fmt = '%#.9f')
d8<-sprintf(chk2[169,], fmt = '%#.9f')
d9<-sprintf(chk2[193,], fmt = '%#.9f')
d10<-sprintf(chk2[217,], fmt = '%#.9f')
d11<-sprintf(chk2[241,], fmt = '%#.9f')
d12<-sprintf(chk2[265,], fmt = '%#.9f')
d13<-sprintf(chk2[289,], fmt = '%#.9f')
d14<-sprintf(chk2[313,], fmt = '%#.9f')
d15<-sprintf(chk2[337,], fmt = '%#.9f')
d16<-sprintf(chk2[361,], fmt = '%#.9f')
df3<-as.data.frame(rbind(d1,d2,d3,d4,d5,d6,d7,d8,d9,d10,d11,d12,d13,d14,d15,d16))
df4<-data.frame(sprintf(df3$V4,fmt='%.5s'), df3$V1, df3$V2, df3$V3, df3$V5, df3$V6, df3$V7)
colnames(df4) <- c("time", "x", "y" ,"z","V1", "V2", "V3")

df4

```

-------------------------


## Simulation Orbit Parameters

```{r}
set.seed(42)
g = 6.67*10^(-11)
gen_some_data = function(n_obs = 50) {
  datetime = "2022-09-12 0:33:42.8348159988855"
  mu = 3.986004418e14 # gravitational parameter
  int_designator = seq(0, 10, length.out = n_obs)
  eccentricity = runif(n = n_obs, min = 0, max = .9)
  focal_param = round(runif(n = n_obs, min = 100, max = 400),4)
  semi_latus_rectum = focal_param*eccentricity  
  semimajor_axis = semi_latus_rectum/abs((1-eccentricity^2))
  classification = sample(c("U", "C", "S"),size=n_obs,replace=TRUE)
  periapsis  = round(runif(n = n_obs, min = 0, max = 360), 4)
  inclination = round(runif(n = n_obs, min = 0, max = 180), 4)
  mean_motion = 360/focal_param
  mean_anomoly <- runif(n = n_obs, min = 0, max = 24) 
  pos_y <- round(runif(n = n_obs, min = -1000, max = 1000),4)
  pos_z <- round(runif(n = n_obs, min = -1000, max = 1000),4)
  acos(dot(n0,e0)/(n1*e1))
  OMEGA0 <- 80.0121*pi/round(runif(n=n_obs, min=180, max=360), 4) 
  nu = round(runif(n = n_obs, min = 0, max = 360), 4)
  longitudePerigee <- OMEGA0 + omega0
  trueLongitude <- longitudePerigee + nu
  day = round(runif(n = n_obs, min = 0, max = 24), 4)
  Bstar <- 0.66816e-4 # drag coefficient
  data.frame(mean_motion, semimajor_axis, semi_latus_rectum, eccentricity, periapsis, mean_anomoly, inclination, omega0, OMEGA0, trueLongitude, longitudePerigee, Bstar, datetime)
}

```

## Build Simulation Data Sets

```{r}
set.seed(123)
orb_data = gen_some_data(n_obs = 5000)
orb_tst = gen_some_data(n_obs = 800)
orb_trn = gen_some_data(n_obs = 400)
summary(orb_trn)

```

### Test the Orbital Data Set Output

```{r}
orb_trn <- as.data.frame(orb_trn)
orb_trn

```

### Propagate the Orbital Parameters

```{r}
targetTimes <- seq(0, 3000, by=5)

results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=orb_trn$mean_motion[50]*((2*pi)/(1440)),
                     e0=orb_trn$eccentricity[50],
                     i0=orb_trn$inclination[50]*pi/180,
                     M0=orb_trn$mean_anomoly[50]*pi/180,
                     omega0=orb_trn$omega0[50]*pi/180,
                     OMEGA0=orb_trn$omega0[50]*pi/180,
                     Bstar=orb_trn$Bstar[50],
                     initialDateTime=orb_trn$datetime[50],
                     targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=orb_trn$mean_motion[10]*((2*pi)/(1440)),
                     e0=orb_trn$eccentricity[10],
                     i0=orb_trn$inclination[10]*pi/180,
                     M0=orb_trn$mean_anomoly[10]*pi/180,
                     omega0=orb_trn$omega0[10]*pi/180,
                     OMEGA0=orb_trn$omega0[10]*pi/180,
                     Bstar=orb_trn$Bstar[10],
                     initialDateTime=orb_trn$datetime[10],
                     targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=orb_trn$mean_motion[32]*((2*pi)/(1440)),
                     e0=orb_trn$eccentricity[32],
                     i0=orb_trn$inclination[32]*pi/180,
                     M0=orb_trn$mean_anomoly[32]*pi/180,
                     omega0=orb_trn$omega0[32]*pi/180,
                     OMEGA0=orb_trn$omega0[32]*pi/180,
                     Bstar=orb_trn$Bstar[32],
                     initialDateTime=orb_trn$datetime[32],
                     targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=orb_trn$mean_motion[7]*((2*pi)/(1440)),
                     e0=orb_trn$eccentricity[7],
                     i0=orb_trn$inclination[7]*pi/180,
                     M0=orb_trn$mean_anomoly[7]*pi/180,
                     omega0=orb_trn$omega0[7]*pi/180,
                     OMEGA0=orb_trn$omega0[7]*pi/180,
                     Bstar=orb_trn$Bstar[7],
                     initialDateTime=orb_trn$datetime[7],
                     targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```

### Plot the Simulated Orbits

```{r}
suppressMessages(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Inclination = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 15',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 30',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext ='Inclination = 45',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig
#htmlwidgets::saveWidget(as_widget(fig), "mwe.html")
```

## Ground-Tracks

```{r}

dateTime1 <- orb_trn$datetime[50]
dateTime2 <- orb_trn$datetime[10]
dateTime3 <- orb_trn$datetime[32]
dateTime4 <- orb_trn$datetime[7]

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="yellow", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```


============================================================

## Test Case 2
The next code chunks loads a random object from the test TLEs, propagates its state vectors from the orbital parameters, updates the date-time, and plots the ground track. Here, we get the object name and its orbital period.

```{r}
test_TLEs <- readTLE(paste0(path.package("asteRisk"), "/testTLE.txt"))
sample.int(22,1)
randSAT_TLE <- test_TLEs[[sample.int(22,1)]]
obj_name <- randSAT_TLE$objectName
obital_period <- 1/randSAT_TLE$meanMotion
print(paste("Object Name:", obj_name))
print(paste("Obital Preiod:", obital_period ))
```
The randomly selected object is the 16925 with a perigee of 82.48 

SL-6 R?B(2) has an orbital period or 0.2047 day. So 8is we want to look at a 5-orbit gorund track, we compute $orbital period \mult 24 (hours/day) x 60 (minutes/hour) x 5 (orbits), with position readings every 5 minutes. So, we calculate that result as well as print the orbital parameters, below.

```{r}
orb_period<-(1/randSAT_TLE$meanMotion)
observation_period<-orb_period*24*60*5

print(paste("Object Name:  ", randSAT_TLE$objectName))
print(paste("Launch Year:  ", randSAT_TLE$launchYear))
print(paste("Mean Motion:  ", randSAT_TLE$meanMotion))
print(paste("Mean Anomaly: ", randSAT_TLE$meanAnomaly))
print(paste("Eccentricity: ", randSAT_TLE$eccentricity))
print(paste("Ascension:    ", randSAT_TLE$ascension))
print(paste("Inclination:  ", randSAT_TLE$inclination))
print(paste("Perigee Arg:  ", randSAT_TLE$perigeeArgument))
print(paste("B-star:       ", randSAT_TLE$Bstar))
print(paste("Obital Period:", 1/randSAT_TLE$meanMotion))
print(paste("Observ Period:", round(4*observation_period,0)))
```

So we set our target times to 5895 position readings taken every five minutes minutes

```{r}

targetTimes <- seq(0, 5895, by=5)

results_position_matrix <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
  new_result<- sgdp4(n0=randSAT_TLE$meanMotion*((2*pi)/(1440)),
                     e0=randSAT_TLE$eccentricity,
                     i0=randSAT_TLE$inclination*pi/180,
                     M0=randSAT_TLE$meanAnomaly*pi/180,
                     omega0=randSAT_TLE$perigeeArgument*pi/180,
                     OMEGA0=randSAT_TLE$ascension*pi/180,
                     Bstar=randSAT_TLE$Bstar,
                     initialDateTime=randSAT_TLE$dateTime,
                     targetTime = targetTimes[i])
    results_position_matrix[i,] <- new_result[[1]]
    results_velocity_matrix[i,] <- new_result[[2]]
}

last_orb_propagation <- new_result
last_orb_propagation$algorithm
results_position_matrix = cbind(results_position_matrix, targetTimes)
colnames(results_position_matrix) <- c("x", "y", "z", "time")

```
Notice that we have a deep space satellite and the algorithm chose the SPD4 propagator model, which is correct.

To map the ground track, we convert from the TEME reference frame to geodetic coordinates.

```{r}
dateTime <- randSAT_TLE$dateTime

ITRF_coordinates <- TEMEtoITRF(last_orb_propagation$position,
                               last_orb_propagation$velocity,
                               new_dateTime)

geodetic_matrix <-matrix(nrow=nrow(results_position_matrix), ncol=3)

for(i in 1:nrow(geodetic_matrix)) {
  new_dateTime <- as.character(as.POSIXct(dateTime, tz = "UTC") + 60 * targetTimes[i])
  new_geodetic <-TEMEtoLATLON(results_position_matrix[i, 1:3]*1000, new_dateTime)
  geodetic_matrix[i,] <- new_geodetic
}

colnames(geodetic_matrix) <- c("latitude", "longitude", "altitude")
```

Before we map the ground track, we plot the orbit to compare with the mapped ground track.

```{r}
randSAT_out<-as.data.frame(results_position_matrix)
fig <-  plot_ly()

fig <- add_trace(
   fig,
   visible=TRUE,
   hovertext = "Eccentricity = 0",
   showlegend=TRUE,
   colors = "red",
   type = 'scatter3d',
   mode = 'line',
   size = I(6),
   x = randSAT_out$x,
   y = randSAT_out$y, 
   z = randSAT_out$z
) 
fig
```

Finally, we plot the ground track using ggmap.

```{r} 
library(ggmap)

ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) +
  geom_point(data=as.data.frame(geodetic_matrix), aes(x=longitude, y=latitude), color="red", size=2.5, alpha=0.8) +
  annotate("label", x=-3, y=75, label = randSAT_TLE$objectName,
    colour = I("red"), size = 8)
```


## Appendix 1

```{r}
targetTimes <- seq(0, 1500, by=10)
sat1<-test_TLEs[[7]]
sat2<-test_TLEs[[4]]
sat3<-test_TLEs[[22]]
sat4<-test_TLEs[[9]]


results_position_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix1 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result1 <- sgdp4(n0=sat1$meanMotion*((2*pi)/(1440)),
                        e0=sat1$eccentricity,
                        i0=sat1$inclination*pi/180,
                        M0=sat1$meanAnomaly*pi/180,
                        omega0=sat1$perigeeArgument*pi/180,
                        OMEGA0=sat1$ascension*pi/180,
                        Bstar=sat1$Bstar,
                        initialDateTime=sat1$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix1[i,] <- new_result1[[1]]
    results_velocity_matrix1[i,] <- new_result1[[2]]
}
last_orb_propagation1 <- new_result1
results_position_matrix1 = cbind(results_position_matrix1, targetTimes)
colnames(results_position_matrix1) <- c("x", "y", "z", "time")

# Let´s verify that the SDP4 algorithm was automatically chosen

results_position_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix2 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result2 <- sgdp4(n0=sat2$meanMotion*((2*pi)/(1440)),
                        e0=sat2$eccentricity,
                        i0=sat2$inclination*pi/180,
                        M0=sat2$meanAnomaly*pi/180,
                        omega0=sat2$perigeeArgument*pi/180,
                        OMEGA0=sat2$ascension*pi/180,
                        Bstar=sat2$Bstar,
                        initialDateTime=sat2$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix2[i,] <- new_result2[[1]]
    results_velocity_matrix2[i,] <- new_result2[[2]]
}
last_orb_propagation2 <- new_result2
results_position_matrix2 = cbind(results_position_matrix2, targetTimes)
colnames(results_position_matrix2) <- c("x", "y", "z", "time")


results_position_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix3 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result3 <- sgdp4(n0=sat3$meanMotion*((2*pi)/(1440)),
                        e0=sat3$eccentricity,
                        i0=sat3$inclination*pi/180,
                        M0=sat3$meanAnomaly*pi/180,
                        omega0=sat3$perigeeArgument*pi/180,
                        OMEGA0=sat3$ascension*pi/180,
                        Bstar=sat3$Bstar,
                        initialDateTime=sat3$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix3[i,] <- new_result3[[1]]
    results_velocity_matrix3[i,] <- new_result3[[2]]
}
last_orb_propagation3 <- new_result3
results_position_matrix3 = cbind(results_position_matrix3, targetTimes)
colnames(results_position_matrix3) <- c("x", "y", "z", "time")


results_position_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)
results_velocity_matrix4 <- matrix(nrow=length(targetTimes), ncol=3)

for(i in 1:length(targetTimes)) {
    new_result4 <- sgdp4(n0=sat4$meanMotion*((2*pi)/(1440)),
                        e0=sat4$eccentricity,
                        i0=sat4$inclination*pi/180,
                        M0=sat4$meanAnomaly*pi/180,
                        omega0=sat4$perigeeArgument*pi/180,
                        OMEGA0=sat4$ascension*pi/180,
                        Bstar=sat4$Bstar,
                        initialDateTime=sat4$dateTime, 
                        targetTime = targetTimes[i])
    results_position_matrix4[i,] <- new_result4[[1]]
    results_velocity_matrix4[i,] <- new_result4[[2]]
}
last_orb_propagation4 <- new_result4
results_position_matrix4 = cbind(results_position_matrix4, targetTimes)
colnames(results_position_matrix4) <- c("x", "y", "z", "time")

```


```{r}
(library(plotly))

out1<-as.data.frame(results_position_matrix1)
out2<-as.data.frame(results_position_matrix2)
out3<-as.data.frame(results_position_matrix3)
out4<-as.data.frame(results_position_matrix4)
out1<-as.data.frame(out1)
out2<-as.data.frame(out2)
out3<-as.data.frame(out3)
out4<-as.data.frame(out4)

fig <-  plot_ly()

fig <- add_trace(
   fig,
   name = sat1$objectName,
   visible=TRUE,
   hovertext = "Eccentricity = 0",
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(4),
   x = out1$x,
   y = out1$y, 
   z = out1$z
) 

fig <- add_trace(
   fig,
   name = sat2$objectName,
   visible=TRUE,
   hovertext ='Eccentricity = 0.3',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(4),
   x = out2$x,
   y = out2$y, 
   z = out2$z
) 

fig <- add_trace(
   fig,
   name = sat3$objectName,
   visible=TRUE,
   hovertext ='Eccentricity = 0.6',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(4),
   x = out3$x,
   y = out3$y, 
   z = out3$z
) 

fig <- add_trace(
   fig,
   name = sat4$objectName,
   visible=TRUE,
   hovertext ='Eccentricity = 0.9',
   showlegend=TRUE,
   type = 'scatter3d',
   mode = 'line',
   size = I(4),
   x = out4$x,
   y = out4$y, 
   z = out4$z
)

fig

```

## Ground-Tracks

```{r}
dateTime1 <- sat1$dateTime
dateTime2 <- sat2$dateTime
dateTime3 <- sat3$dateTime
dateTime4 <- sat4$dateTime

ITRF_coordinates1 <- TEMEtoITRF(last_orb_propagation1$position,
                               last_orb_propagation1$velocity,
                               dateTime1)
ITRF_coordinates2 <- TEMEtoITRF(last_orb_propagation2$position,
                               last_orb_propagation2$velocity,
                               dateTime2)
ITRF_coordinates3 <- TEMEtoITRF(last_orb_propagation3$position,
                               last_orb_propagation3$velocity,
                               dateTime3)
ITRF_coordinates4 <- TEMEtoITRF(last_orb_propagation4$position,
                               last_orb_propagation4$velocity,
                               dateTime4)
                               
geodetic_matrix1 <-matrix(nrow=nrow(results_position_matrix1), ncol=3)
geodetic_matrix2 <-matrix(nrow=nrow(results_position_matrix2), ncol=3)
geodetic_matrix3 <-matrix(nrow=nrow(results_position_matrix3), ncol=3)
geodetic_matrix4 <-matrix(nrow=nrow(results_position_matrix4), ncol=3)

for(i in 1:nrow(geodetic_matrix1)) {
    new_dateTime1 <- as.character(as.POSIXct(dateTime1, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime2 <- as.character(as.POSIXct(dateTime2, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime3 <- as.character(as.POSIXct(dateTime3, tz = "UTC") + 60 * targetTimes[i])
    new_dateTime4 <- as.character(as.POSIXct(dateTime4, tz = "UTC") + 60 * targetTimes[i])
    new_geodetic1 <-TEMEtoLATLON(results_position_matrix1[i, 1:3]*1000,new_dateTime1)
    geodetic_matrix1[i,] <- new_geodetic1
    new_geodetic2 <-TEMEtoLATLON(results_position_matrix2[i, 1:3]*1000,new_dateTime2)
    geodetic_matrix2[i,] <- new_geodetic2
    new_geodetic3 <-TEMEtoLATLON(results_position_matrix3[i, 1:3]*1000,new_dateTime3)
    geodetic_matrix3[i,] <- new_geodetic3
    new_geodetic4 <-TEMEtoLATLON(results_position_matrix4[i, 1:3]*1000,new_dateTime4)
    geodetic_matrix4[i,] <- new_geodetic4    
}
colnames(geodetic_matrix1) <- c("latitude1", "longitude1", "altitude1")
colnames(geodetic_matrix2) <- c("latitude2", "longitude2", "altitude2")
colnames(geodetic_matrix3) <- c("latitude3", "longitude3", "altitude3")
colnames(geodetic_matrix4) <- c("latitude4", "longitude4", "altitude4")

```


```{r}
library(ggmap)
ggmap(get_map(c(left=-180, right=180, bottom=-80, top=80))) + 
  geom_point(data=as.data.frame(geodetic_matrix1), aes(x=longitude1, y=latitude1), color="blue", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix2), aes(x=longitude2, y=latitude2), color="orange", size=2.5, alpha=0.8)+
    geom_point(data=as.data.frame(geodetic_matrix3), aes(x=longitude3, y=latitude3), color="green", size=2.5, alpha=0.8)+
  geom_point(data=as.data.frame(geodetic_matrix4), aes(x=longitude4, y=latitude4), color="red", size=2.5, alpha=0.8)

```

## Appendix 2

```{r} 
c1 <- cbind('international designator', 'INTD', 'seq(0, 10, length.out = n_obs)')
c2 <- cbind(  'eccentricity', '$e$', 'runif(n = n_obs, min = 0, max = 2.5)')
c3 <- cbind(  'focal parameter', '$p$', 'round(runif(n = n_obs, min = 100, max = 400),4)')
c4 <- cbind(  'semi latus rectum', "$\\ell$", 'focal parameter*eccentricity') 
c5 <- cbind(  'semimajor axis', '$a$', 'semi_latus_rectum/abs((1-eccentricity^2))')
c6 <- cbind( 'semiminor axis', '$b$', 'semi_latus_rectum/abs((1-eccentricity^2))')
c7 <- cbind(  'classification', 'class' ,'sample(c("U", "C", "S"), size = n_obs, replace = TRUE)')
c8 <- cbind(  'periapsis', "r_", 'round(runif(n = n_obs, min = 0, max = 360), 4)')
c9 <- cbind(  'inclination', '$i$', 'round(runif(n = n_obs, min = 0, max = 180), 4)')
c10 <- cbind(  'mean motion', '$n$', 'round(runif(n = n_obs, min = 0, max = 360),4)')
c11 <- cbind(  'true anomaly',"$\\nu$", 'round(runif(n = n_obs, min = 0, max = 360),4)')
c12 <- cbind(  'mean anomaly', '$M$', 'round(runif(n = n_obs, min = 0, max = 360),4)')
c13 <- cbind(  'longitude of periapsis', "$\\omega$", 'round(runif(n = n_obs, min = 180, max = 360),4)') 
c14 <- cbind(  'longitude of ascending node', "$\\Omega$" ,'round(runif(n = n_obs, min = 180, max = 360), 4)')  
c15 <- cbind(  'true longitude', "$l$", 'round(runif(n = n_obs, min = 0, max = 360),4)')
c16 <- cbind(  'Y component of position vector', "$r_y$", 'round(runif(n = n_obs, min = -1000, max = 1000),4)')
c17 <- cbind(  'Z component of position vector', "$r_z$", 'round(runif(n = n_obs, min = -1000, max = 1000),4)')
c18 <- cbind(  'Y component of velocity vector', "$v_y$", 'round(runif(n = n_obs, min = -1000, max = 1000),4)')
c19 <- cbind(  'Z component of velocity vector', "$v_z$", 'round(runif(n = n_obs, min = -1000, max = 1000),4)')
c20 <- cbind(  'day', 'day', 'round(runif(n = n_obs, min = 0, max = 24), 4)')
c21 <- cbind(  'drag coefficient',"$B*$", '0.66816e-4')
c22 <- cbind(  'gravitational parameter', "$\\mu$", '3.986004418e14')
 
tab <- rbind(c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16,c17,c18,c19,c20,c21,c22)
tab1<-data.frame(tab)

library(knitr) 
library(kableExtra) 
kable(tab1, col.names=c('Parameter', 'Symbol', 'Range of Values'), caption = "Orbital Parameters and Range of Values", align='l', booktabs = T) %>%
kable_styling(full_width = T) %>%
column_spec(1, width = "8cm")

```

## References

https://celestrak.com/NORAD/documentation/spacetrk.pdf

http://www.celestrak.com/publications/aiaa/2006-6753/AIAA-2006-6753.pdf

https://juliapackages.com/p/satellitetoolbox

https://celestrak.com/columns/v04n03/#FAQ01

https://www.space-track.org

Satellite Orbits: Models, Methods and Applications. Oliver Montenbruck and Eberhard Gill.

Fundamentals of Astrodynamics and Applications. David Vallado.
